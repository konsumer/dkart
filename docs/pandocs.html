<HTML>
 <HEAD>
  <script language="JavaScript">
   <!--
    if (parent.location.href == self.location.href)
     { window.location.href =
      'http://verhoeven272.nl/cgi-bin/FSgz?fruttenboel%2FGameboy&Fruttenboel+GameBoy&GBtop&pandocs&GBcontent'
     }
   // -->
  </script>
  <TITLE>Specifications</TITLE>
  <link type="text/css" rel="stylesheet" href="../frutt.css">
  <META NAME="GENERATOR" CONTENT="nocash XED2HTM converter">
 </HEAD>
 <BODY bgcolor="#ffffff" text="#000000" link="#0033cc" vlink="#0033cc" alink="#0033cc">
  <table width="100%" cellpadding="5"><tr><td>
  <TABLE WIDTH=100%>
   <TR bgcolor="#cccccc">
    <TD>
     <A NAME="pandocs"></A><FONT SIZE=+2>&nbsp;Pan Docs</FONT>
    </TD>
   </TR>
  </TABLE>
  <BR>
  <B>Overview<BR>
</B><A HREF="#aboutthepandocs">About the Pan Docs</A><BR>
<A HREF="#gameboytechnicaldata">Game Boy Technical Data</A><BR>
<A HREF="#memorymap">Memory Map</A><BR>
<BR>
<B>I/O Ports<BR>
</B><A HREF="#videodisplay">Video Display</A><BR>
<A HREF="#soundcontroller">Sound Controller</A><BR>
<A HREF="#joypadinput">Joypad Input</A><BR>
<A HREF="#serialdatatransferlinkcable">Serial Data Transfer (Link Cable)</A><BR>
<A HREF="#timeranddividerregisters">Timer and Divider Registers</A><BR>
<A HREF="#interrupts">Interrupts</A><BR>
<A HREF="#cgbregisters">CGB Registers</A><BR>
<A HREF="#sgbfunctions">SGB Functions</A><BR>
<BR>
<B>CPU Specifications<BR>
</B><A HREF="#cpuregistersandflags">CPU Registers and Flags</A><BR>
<A HREF="#cpuinstructionset">CPU Instruction Set</A><BR>
<A HREF="#cpucomparisionwithz80">CPU Comparision with Z80</A><BR>
<BR>
<B>Cartridges<BR>
</B><A HREF="#thecartridgeheader">The Cartridge Header</A><BR>
<A HREF="#memorybankcontrollers">Memory Bank Controllers</A><BR>
<A HREF="#gamegeniesharkcheats">Gamegenie/Shark Cheats</A><BR>
<BR>
<B>Other<BR>
</B><A HREF="#powerupsequence">Power Up Sequence</A><BR>
<A HREF="#reducingpowerconsumption">Reducing Power Consumption</A><BR>
<A HREF="#spriterambug">Sprite RAM Bug</A><BR>
<A HREF="#externalconnectors">External Connectors</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="aboutthepandocs"></A><FONT SIZE=+2>&nbsp;About the Pan Docs</FONT></TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE> =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>                     * but were afraid to ask
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa
</TD></TR></TABLE><BR>
<B>Forward<BR>
</B>The following was typed up for informational purposes regarding the 
inner workings on the hand-held game machine known as GameBoy, 
manufactured and designed by Nintendo Co., LTD. This info is presented 
to inform a user on how their Game Boy works and what makes it "tick". 
GameBoy is copyrighted by Nintendo Co., LTD. Any reference to 
copyrighted material is not presented for monetary gain, but for 
educational purposes and higher learning.<BR>
<BR>
<B>Available Document Formats<BR>
</B>The present version of this document is available in Text and Html format:<BR>
<TABLE><TR><TD><PRE>  http://www.work.de/nocash/pandocs.txt
  http://www.work.de/nocash/pandocs.htm
</TD></TR></TABLE>Also, a copy of this document is included in the manual of newer 
versions of the no$gmb debugger, because of recent piracy attacks (many 
thanks and best wishes go to hell) I have currently no intention to 
publish any such or further no$gmb updates though.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="gameboytechnicaldata"></A><FONT SIZE=+2>&nbsp;Game Boy Technical Data</FONT></TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  CPU          - 8-bit (Similar to the Z80 processor)
  Clock Speed  - 4.194304MHz (4.295454MHz for SGB, max. 8.4MHz for CGB)
  Work RAM     - 8K Byte (32K Byte for CGB)
  Video RAM    - 8K Byte (16K Byte for CGB)
  Screen Size  - 2.6"
  Resolution   - 160x144 (20x18 tiles)
  Max sprites  - Max 40 per screen, 10 per line
  Sprite sizes - 8x8 or 8x16
  Palettes     - 1x4 BG, 2x3 OBJ (for CGB: 8x4 BG, 8x3 OBJ)
  Colors       - 4 grayshades (32768 colors for CGB)
  Horiz Sync   - 9198 KHz (9420 KHz for SGB)
  Vert Sync    - 59.73 Hz (61.17 Hz for SGB)
  Sound        - 4 channels with stereo sound
  Power        - DC6V 0.7W (DC3V 0.7W for GB Pocket, DC3V 0.6W for CGB)
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="memorymap"></A><FONT SIZE=+2>&nbsp;Memory Map</FONT></TD></TR></TABLE><BR>
The gameboy is having a 16bit address bus, that is used to address ROM, 
RAM, and I/O registers.<BR>
<BR>
<B>General Memory Map<BR>
</B><TABLE><TR><TD><PRE>  0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
  4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
  8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
  A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
  C000-CFFF   4KB Work RAM Bank 0 (WRAM)
  D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
  E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
  FE00-FE9F   Sprite Attribute Table (OAM)
  FEA0-FEFF   Not Usable
  FF00-FF7F   I/O Ports
  FF80-FFFE   High RAM (HRAM)
  FFFF        Interrupt Enable Register
</TD></TR></TABLE><BR>
<B>Jump Vectors in First ROM Bank<BR>
</B>The following addresses are supposed to be used as jump vectors:<BR>
<TABLE><TR><TD><PRE>  0000,0008,0010,0018,0020,0028,0030,0038   for RST commands
  0040,0048,0050,0058,0060                  for Interrupts
</TD></TR></TABLE>However, the memory may be used for any other purpose in case that your 
program doesn't use any (or only some) RST commands or Interrupts. RST 
commands are 1-byte opcodes that work similiar to CALL opcodes, except 
that the destination address is fixed.<BR>
<BR>
<B>Cartridge Header in First ROM Bank<BR>
</B>The memory at 0100-014F contains the cartridge header. This area 
contains information about the program, its entry point, checksums, 
information about the used MBC chip, the ROM and RAM sizes, etc. Most of 
the bytes in this area are required to be specified correctly. For more 
information read the chapter about The Cartridge Header.<BR>
<BR>
<B>External Memory and Hardware<BR>
</B>The areas from 0000-7FFF and A000-BFFF may be used to connect external 
hardware. The first area is typically used to address ROM (read only, of 
course), cartridges with Memory Bank Controllers (MBCs) are additionally 
using this area to output data (write only) to the MBC chip. The second 
area is often used to address external RAM, or to address other external 
hardware (Real Time Clock, etc). External memory is often battery 
buffered, and may hold saved game positions and high scrore tables 
(etc.) even when the gameboy is turned of, or when the cartridge is 
removed. For specific information read the chapter about Memory Bank 
Controllers.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="videodisplay"></A><FONT SIZE=+2>&nbsp;Video Display</FONT></TD></TR></TABLE><BR>
<B>Video I/O Registers<BR>
</B><A HREF="#lcdcontrolregister">LCD Control Register</A><BR>
<A HREF="#lcdstatusregister">LCD Status Register</A><BR>
<A HREF="#lcdinterrupts">LCD Interrupts</A><BR>
<A HREF="#lcdpositionandscrolling">LCD Position and Scrolling</A><BR>
<A HREF="#lcdmonochromepalettes">LCD Monochrome Palettes</A><BR>
<A HREF="#lcdcolorpalettescgbonly">LCD Color Palettes (CGB only)</A><BR>
<A HREF="#lcdvrambankcgbonly">LCD VRAM Bank (CGB only)</A><BR>
<A HREF="#lcdoamdmatransfers">LCD OAM DMA Transfers</A><BR>
<A HREF="#lcdvramdmatransferscgbonly">LCD VRAM DMA Transfers (CGB only)</A><BR>
<BR>
<B>Video Memory<BR>
</B><A HREF="#vramtiledata">VRAM Tile Data</A><BR>
<A HREF="#vrambackgroundmaps">VRAM Background Maps</A><BR>
<A HREF="#vramspriteattributetableoam">VRAM Sprite Attribute Table (OAM)</A><BR>
<A HREF="#accessingvramandoam">Accessing VRAM and OAM</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdcontrolregister"></A><FONT SIZE=+2>&nbsp;LCD Control Register</FONT></TD></TR></TABLE><BR>
<B>FF40 - LCDC - LCD Control (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG & Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)
</TD></TR></TABLE><BR>
<B>LCDC.7 - LCD Display Enable<BR>
</B>CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed
during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the
hardware. This appears to be a serious issue,
Nintendo is reported to reject any games that do not follow this rule.<BR>
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the
display is disabled the screen is blank (white), and
VRAM and OAM can be accessed freely.<BR>
<BR>
--- LCDC.0 has different Meanings depending on Gameboy Type ---<BR>
<BR>
<B>LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display<BR>
</B>When Bit 0 is cleared, the background becomes blank (white). Window and 
Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).<BR>
<BR>
<B>LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority<BR>
</B>When Bit 0 is cleared, the background and window lose their priority - 
the sprites will be always displayed on top of background and window, 
independently of the priority flags in OAM and BG Map attributes.<BR>
<BR>
<B>LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display<BR>
</B>When Bit 0 is cleared, both background and window become blank (white), 
ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites 
may still be displayed (if enabled in Bit 1).<BR>
This is a possible compatibility problem - any monochrome games (if any) 
that disable the background, but still want to display the window 
wouldn't work properly on CGBs.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdstatusregister"></A><FONT SIZE=+2>&nbsp;LCD Status Register</FONT></TD></TR></TABLE><BR>
<B>FF41 - STAT - LCDC Status   (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver
</TD></TR></TABLE><BR>
The two lower STAT bits show the current status of the LCD controller.<BR>
<TABLE><TR><TD><PRE>  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.
</TD></TR></TABLE><BR>
The following are typical when the display is enabled:<BR>
<TABLE><TR><TD><PRE>  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____
</TD></TR></TABLE><BR>
The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 
109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This 
is interrupted every 16.6ms by the VBlank (1). The mode flag stays set 
at 1 for about 1.08 ms.<BR>
<BR>
Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 
169-175 clks. A complete cycle through these states takes 456 clks. 
VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 
clks.)<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdinterrupts"></A><FONT SIZE=+2>&nbsp;LCD Interrupts</FONT></TD></TR></TABLE><BR>
<B>INT 40 - V-Blank Interrupt<BR>
</B>The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and 
ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at 
the beginning of the V-Blank period (LY=144).<BR>
During this period video hardware is not using video ram so it may be 
freely accessed. This period lasts approximately 1.1 milliseconds.<BR>
<BR>
<B>INT 48 - LCDC Status Interrupt<BR>
</B>There are various reasons for this interrupt to occur as described by 
the STAT register ($FF40). One very popular reason is to indicate to the 
user when the video hardware is about to redraw a given LCD line. This 
can be useful for dynamically controlling the SCX/SCY registers 
($FF43/$FF42) to perform special video effects.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdpositionandscrolling"></A><FONT SIZE=+2>&nbsp;LCD Position and Scrolling</FONT></TD></TR></TABLE><BR>
<B>FF42 - SCY - Scroll Y   (R/W)<BR>
FF43 - SCX - Scroll X   (R/W)<BR>
</B>Specifies the position in the 256x256 pixels BG map (32x32 tiles) which 
is to be displayed at the upper/left LCD display position.<BR>
Values in range from 0-255 may be used for X/Y each, the video 
controller automatically wraps back to the upper (left) position in BG 
map when drawing exceeds the lower (right) border of the BG map area.<BR>
<BR>
<B>FF44 - LY - LCDC Y-Coordinate (R)<BR>
</B>The LY indicates the vertical line to which the present data is 
transferred to the LCD Driver. The LY can take on any value between 0 
through 153. The values between 144 and 153 indicate the V-Blank period. 
Writing will reset the counter.<BR>
<BR>
<B>FF45 - LYC - LY Compare  (R/W)<BR>
</B>The gameboy permanently compares the value of the LYC and LY registers. 
When both values are identical, the coincident bit in the STAT register 
becomes set, and (if enabled) a STAT interrupt is requested.<BR>
<BR>
<B>FF4A - WY - Window Y Position (R/W)<BR>
FF4B - WX - Window X Position minus 7 (R/W)<BR>
</B>Specifies the upper/left positions of the Window area. (The window is an 
alternate background area which can be displayed above of the normal 
background. OBJs (sprites) may be still displayed above or behinf the 
window, just as for normal BG.)<BR>
The window becomes visible (if enabled) when positions are set in range 
WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at 
upper left, it is then completly covering normal background.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdmonochromepalettes"></A><FONT SIZE=+2>&nbsp;LCD Monochrome Palettes</FONT></TD></TR></TABLE><BR>
<B>FF47 - BGP - BG Palette Data  (R/W) - Non CGB Mode Only<BR>
</B>This register assigns gray shades to the color numbers of the BG and 
Window tiles.<BR>
<TABLE><TR><TD><PRE>  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0
</TD></TR></TABLE>The four possible gray shades are:<BR>
<TABLE><TR><TD><PRE>  0  White
  1  Light gray
  2  Dark gray
  3  Black
</TD></TR></TABLE>In CGB Mode the Color Palettes are taken from CGB Palette Memory 
instead.<BR>
<BR>
<B>FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only<BR>
</B>This register assigns gray shades for sprite palette 0. It works exactly 
as BGP (FF47), except that the lower two bits aren't used because sprite 
data 00 is transparent.<BR>
<BR>
<B>FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only<BR>
</B>This register assigns gray shades for sprite palette 1. It works exactly 
as BGP (FF47), except that the lower two bits aren't used because sprite 
data 00 is transparent.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdcolorpalettescgbonly"></A><FONT SIZE=+2>&nbsp;LCD Color Palettes (CGB only)</FONT></TD></TR></TABLE><BR>
<B>FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index<BR>
</B>This register is used to address a byte in the CGBs Background Palette 
Memory. Each two byte in that memory define a color value. The first 8 
bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.<BR>
<TABLE><TR><TD><PRE>  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)
</TD></TR></TABLE>Data can be read/written to/from the specified index address through 
Register FF69. When the Auto Increment Bit is set then the index is 
automatically incremented after each &lt;write&gt; to FF69. Auto Increment has 
no effect when &lt;reading&gt; from FF69, so the index must be manually 
incremented in that case.<BR>
<BR>
<B>FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data<BR>
</B>This register allows to read/write data to the CGBs Background Palette 
Memory, addressed through Register FF68.<BR>
Each color is defined by two bytes (Bit 0-7 in first byte).<BR>
<TABLE><TR><TD><PRE>  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)
</TD></TR></TABLE>Much like VRAM, Data in Palette Memory cannot be read/written during the 
time when the LCD Controller is reading from it. (That is when the STAT 
register indicates Mode 3).<BR>
Note: Initially all background colors are initialized as white.<BR>
<BR>
<B>FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index<BR>
FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data<BR>
</B>These registers are used to initialize the Sprite Palettes OBP0-7, 
identically as described above for Background Palettes. Note that four 
colors may be defined for each OBP Palettes - but only Color 1-3 of each 
Sprite Palette can be displayed, Color 0 is always transparent, and can 
be initialized to a don't care value.<BR>
Note: Initially all sprite colors are uninitialized.<BR>
<BR>
<B>RGB Translation by CGBs<BR>
</B>When developing graphics on PCs, note that the RGB values will have 
different appearance on CGB displays as on VGA monitors:<BR>
The highest intensity will produce Light Gray color rather than White. 
The intensities are not linear; the values 10h-1Fh will all appear very 
bright, while medium and darker colors are ranged at 00h-0Fh.<BR>
The CGB display will mix colors quite oddly, increasing intensity of 
only one R,G,B color will also influence the other two R,G,B colors.<BR>
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will 
appear as Neon Green on VGA displays, but on the CGB it'll produce a 
decently washed out Yellow.<BR>
<BR>
<B>RGB Translation by GBAs<BR>
</B>Even though GBA is described to be compatible to CGB games, most CGB 
games are completely unplayable on GBAs because most colors are 
invisible (black). Of course, colors such like Black and White will 
appear the same on both CGB and GBA, but medium intensities are arranged 
completely different.<BR>
Intensities in range 00h..0Fh are invisible/black (unless eventually 
under best sunlight circumstances, and when gazing at the screen under 
obscure viewing angles), unfortunately, these intensities are regulary 
used by most existing CGB games for medium and darker colors.<BR>
Newer CGB games may avoid this effect by changing palette data when 
detecting GBA hardware. A relative simple method would be using the 
formula GBA=CGB/2+10h for each R,G,B intensity, probably the result 
won't be perfect, and (once colors became visible) it may turn out that 
the color mixing is different also, anyways, it'd be still ways better 
than no conversion.<BR>
Asides, this translation method should have been VERY easy to implement 
in GBA hardware directly, even though Nintendo obviously failed to do 
so. How did they say, This seal is your assurance for excellence in 
workmanship and so on?<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdvrambankcgbonly"></A><FONT SIZE=+2>&nbsp;LCD VRAM Bank (CGB only)</FONT></TD></TR></TABLE><BR>
<B>FF4F - VBK - CGB Mode Only - VRAM Bank<BR>
</B>This 1bit register selects the current Video Memory (VRAM) Bank.<BR>
<TABLE><TR><TD><PRE>  Bit 0 - VRAM Bank (0-1)
</TD></TR></TABLE>Bank 0 contains 192 Tiles, and two background maps, just as for 
monochrome games. Bank 1 contains another 192 Tiles, and color attribute 
maps for the background maps in bank 0.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdoamdmatransfers"></A><FONT SIZE=+2>&nbsp;LCD OAM DMA Transfers</FONT></TD></TR></TABLE><BR>
<B>FF46 - DMA - DMA Transfer and Start Address (W)<BR>
</B>Writing to this register launches a DMA transfer from ROM or RAM to OAM 
memory (sprite attribute table). The written value specifies the 
transfer source address divided by 100h, ie. source & destination are:<BR>
<TABLE><TR><TD><PRE>  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F
</TD></TR></TABLE>It takes 160 microseconds until the transfer has completed (80 
microseconds in CGB Double Speed Mode), during this time the CPU can 
access only HRAM (memory at FF80-FFFE). For this reason, the programmer 
must copy a short procedure into HRAM, and use this procedure to start 
the transfer from inside HRAM, and wait until the transfer has finished:<BR>
<TABLE><TR><TD><PRE>   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
</TD></TR></TABLE>Most programs are executing this procedure from inside of their VBlank 
procedure, but it is possible to execute it during display redraw also, 
allowing to display more than 40 sprites on the screen (ie. for example 
40 sprites in upper half, and other 40 sprites in lower half of the 
screen).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdvramdmatransferscgbonly"></A><FONT SIZE=+2>&nbsp;LCD VRAM DMA Transfers (CGB only)</FONT></TD></TR></TABLE><BR>
<B>FF51 - HDMA1 - CGB Mode Only - New DMA Source, High<BR>
FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low<BR>
FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High<BR>
FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low<BR>
FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start<BR>
</B>These registers are used to initiate a DMA transfer from ROM or RAM to 
VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, 
the lower four bits of the address are ignored (treated as zero). The 
Destination Start Address may be located at 8000-9FF0, the lower four 
bits of the address are ignored (treated as zero), the upper 3 bits are 
ignored either (destination is always in VRAM).<BR>
<BR>
Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify 
the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h 
bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 
indicates the Transfer Mode:<BR>
<BR>
<B>Bit7=0 - General Purpose DMA<BR>
</B>When using this transfer method, all data is transferred at once. The 
execution of the program is halted until the transfer has completed. 
Note that the General Purpose DMA blindly attempts to copy the data, 
even if the LCD controller is currently accessing VRAM. So General 
Purpose DMA should be used only if the Display is disabled, or during 
V-Blank, or (for rather short blocks) during H-Blank.<BR>
The execution of the program continues when the transfer has been 
completed, and FF55 then contains a value if FFh.<BR>
<BR>
<B>Bit7=1 - H-Blank DMA<BR>
</B>The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at 
LY=0-143, no data is transferred during V-Blank (LY=144-153), but the 
transfer will then continue at LY=00. The execution of the program is 
halted during the separate transfers, but the program execution 
continues during the 'spaces' between each data block.<BR>
Note that the program may not change the Destination VRAM bank (FF4F), 
or the Source ROM/RAM bank (in case data is transferred from bankable 
memory) until the transfer has completed!<BR>
Reading from Register FF55 returns the remaining length (divided by 10h, 
minus 1), a value of 0FFh indicates that the transfer has completed. It 
is also possible to terminate an active H-Blank transfer by writing zero 
to Bit 7 of FF55. In that case reading from FF55 may return any value 
for the lower 7 bits, but Bit 7 will be read as "1".<BR>
<BR>
<B>Confirming if the DMA Transfer is Active<BR>
</B>Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is 
active (1=Not Active, 0=Active). This works under any circumstances - 
after completion of General Purpose, or H-Blank Transfer, and after 
manually terminating a H-Blank Transfer.<BR>
<BR>
<B>Transfer Timings<BR>
</B>In both Normal Speed and Double Speed Mode it takes about 8us to 
transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, 
and 16 'fast' cycles in Double Speed Mode.<BR>
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed 
to support General Purpose or H-Blank DMA, that's because there are 
always 2 bytes transferred per microsecond (even if the itself program 
runs it Normal Speed Mode).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="vramtiledata"></A><FONT SIZE=+2>&nbsp;VRAM Tile Data</FONT></TD></TR></TABLE><BR>
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines 
the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because 
memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.<BR>
<BR>
Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray 
shades. Tiles can be displayed as part of the Background/Window map, 
and/or as OAM tiles (foreground sprites). Note that foreground sprites 
may have only 3 colors, because color 0 is transparent.<BR>
<BR>
As it was said before, there are two Tile Pattern Tables at $8000-8FFF 
and at $8800-97FF. The first one can be used for sprites and the 
background. Its tiles are numbered from 0 to 255. The second table can 
be used for the background and the window display and its tiles are 
numbered from -128 to 127.<BR>
<BR>
Each Tile occupies 16 bytes, where each 2 bytes represent a line:<BR>
<TABLE><TR><TD><PRE>  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.
</TD></TR></TABLE>For each line, the first byte defines the least significant bits of the 
color numbers for each pixel, and the second byte defines the upper bits 
of the color numbers. In either case, Bit 7 is the leftmost pixel, and 
Bit 0 the rightmost.<BR>
<BR>
So, each pixel is having a color number in range from 0-3. The color 
numbers are translated into real colors (or gray shades) depending on 
the current palettes. The palettes are defined through registers 
FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="vrambackgroundmaps"></A><FONT SIZE=+2>&nbsp;VRAM Background Maps</FONT></TD></TR></TABLE><BR>
The gameboy contains two 32x32 tile background maps in VRAM at addresses 
9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display "normal" 
background, or "window" background.<BR>
<BR>
<B>BG Map Tile Numbers<BR>
</B>An area of VRAM known as Background Tile Map contains the numbers of 
tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each 
byte contains a number of a tile to be displayed. Tile patterns are 
taken from the Tile Data Table located either at $8000-8FFF or 
$8800-97FF. In the first case, patterns are numbered with unsigned 
numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the 
second case, patterns have signed numbers from -128 to 127 (i.e. pattern 
#0 lies at address $9000). The Tile Data Table address for the 
background can be selected via LCDC register.<BR>
<BR>
<B>BG Map Attributes (CGB Mode only)<BR>
</B>In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 
(each byte defines attributes for the corresponding tile-number map 
entry in VRAM Bank 0):<BR>
<TABLE><TR><TD><PRE>  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)
</TD></TR></TABLE>When Bit 7 is set, the corresponding BG tile will have priority above 
all OBJs (regardless of the priority bits in OAM memory). There's also 
an Master Priority flag in LCDC register Bit 0 which overrides all other 
priority bits when cleared.<BR>
<BR>
As one background tile has a size of 8x8 pixels, the BG maps may hold a 
picture of 256x256 pixels, an area of 160x144 pixels of this picture can 
be displayed on the LCD screen.<BR>
<BR>
<B>Normal Background (BG)<BR>
</B>The SCY and SCX registers can be used to scroll the background, allowing 
to select the origin of the visible 160x144 pixel area within the total 
256x256 pixel background map. Background wraps around the screen (i.e. 
when part of it goes off the screen, it appears on the opposite side.)<BR>
<BR>
<B>The Window<BR>
</B>Besides background, there is also a "window" overlaying the background. 
The window is not scrollable i.e. it is always displayed starting from 
its left upper corner. The location of a window on the screen can be 
adjusted via WX and WY registers. Screen coordinates of the top left 
corner of a window are WX-7,WY. The tiles for the window are stored in 
the Tile Data Table. Both the Background and the window share the same 
Tile Data Table.<BR>
<BR>
Both background and window can be disabled or enabled separately via 
bits in the LCDC register.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="vramspriteattributetableoam"></A><FONT SIZE=+2>&nbsp;VRAM Sprite Attribute Table (OAM)</FONT></TD></TR></TABLE><BR>
GameBoy video controller can display up to 40 sprites either in 8x8 or 
in 8x16 pixels. Because of a limitation of hardware, only ten sprites 
can be displayed per scan line. Sprite patterns have the same format as 
BG tiles, but they are taken from the Sprite Pattern Table located at 
$8000-8FFF and have unsigned numbering.<BR>
<BR>
Sprite attributes reside in the Sprite Attribute Table (OAM - Object 
Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four 
bytes with the following meanings:<BR>
<BR>
<B>Byte0 - Y Position<BR>
</B>Specifies the sprites vertical position on the screen (minus 16).<BR>
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.<BR>
<BR>
<B>Byte1 - X Position<BR>
</B>Specifies the sprites horizontal position on the screen (minus 8).<BR>
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite<BR>
still affects the priority ordering - a better way to hide a sprite is 
to set its Y-coordinate offscreen.<BR>
<BR>
<B>Byte2 - Tile/Pattern Number<BR>
</B>Specifies the sprites Tile Number (00-FF). This (unsigned) value selects 
a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in 
VRAM Bank 0 or 1, depending on Bit 3 of the following byte.<BR>
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 
8x8 tile is "NN AND FEh", and the lower 8x8 tile is "NN OR 01h".<BR>
<BR>
<B>Byte3 - Attributes/Flags:<BR>
</B><TABLE><TR><TD><PRE>  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
</TD></TR></TABLE><BR>
<B>Sprite Priorities and Conflicts<BR>
</B>When sprites with different x coordinate values overlap, the one with 
the smaller x coordinate (closer to the left) will have priority and 
appear above any others. This applies in Non CGB Mode only.<BR>
When sprites with the same x coordinate values overlap, they have 
priority according to table ordering. (i.e. $FE00 - highest, $FE04 - 
next highest, etc.) In CGB Mode priorities are always assigned like 
this.<BR>
<BR>
Only 10 sprites can be displayed on any one line. When this limit is 
exceeded, the lower priority sprites (priorities listed above) won't be 
displayed. To keep unused sprites from affecting onscreen sprites set 
their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to 
X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other 
sprites sharing the same lines.<BR>
<BR>
<B>Writing Data to OAM Memory<BR>
</B>The recommened method is to write the data to normal RAM first, and to 
copy that RAM to OAM by using the DMA transfer function, initiated 
through DMA register (FF46).<BR>
Beside for that, it is also possible to write data directly to the OAM 
area by using normal LD commands, this works only during the H-Blank and 
V-Blank periods. The current state of the LCD controller can be read out 
from the STAT register (FF41).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="accessingvramandoam"></A><FONT SIZE=+2>&nbsp;Accessing VRAM and OAM</FONT></TD></TR></TABLE><BR>
<B>CAUTION<BR>
</B>When the LCD Controller is drawing the screen it is directly reading 
from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). 
During these periods the Gameboy CPU may not access the VRAM and OAM. 
That means, any attempts to write to VRAM/OAM are ignored (the data 
remains unchanged). And any attempts to read from VRAM/OAM will return 
undefined data (typically a value of FFh).<BR>
<BR>
For this reason the program should verify if VRAM/OAM is accessable 
before actually reading or writing to it. This is usually done by 
reading the Mode Bits from the STAT Register (FF41). When doing this (as 
described in the examples below) you should take care that no interrupts 
occur between the wait loops and the following memory access - the 
memory is guaranted to be accessable only for a few cycles directly 
after the wait loops have completed.<BR>
<BR>
<B>VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2<BR>
</B><TABLE><TR><TD><PRE>  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period
</TD></TR></TABLE>A typical procedure that waits for accessibility of VRAM would be:<BR>
<TABLE><TR><TD><PRE>  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/
</TD></TR></TABLE>Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is 
still proof to assume that VRAM can be accessed for a few more cycles 
because in either case the following period is Mode 2 which allows 
access to VRAM either.<BR>
In CGB Mode an alternate method to write data to VRAM is to use the HDMA 
Function (FF51-FF55).<BR>
<BR>
<B>OAM (memory at FE00h-FE9Fh) is accessable during Mode 0-1<BR>
</B><TABLE><TR><TD><PRE>  Mode 0 - H-Blank Period, and
  Mode 1 - V-Blank Period
</TD></TR></TABLE>Beside for that, OAM can be accessed at any time by using the DMA 
Function (FF46). When directly reading or writing to OAM, a typical 
procedure that waits for accessibilty or OAM Memory would be:<BR>
<TABLE><TR><TD><PRE>  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/
</TD></TR></TABLE>The two wait loops ensure that Mode 0 or 1 will last for a few clock 
cycles after completion of the procedure. In V-Blank period it might be 
recommended to skip the whole procedure - and in most cases using the 
above mentioned DMA function would be more recommended anyways.<BR>
<BR>
<B>Note<BR>
</B>When the display is disabled, both VRAM and OAM are accessable at any 
time. The downside is that the screen is blank (white) during this 
period, so that disabling the display would be recommended only during 
initialization.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundcontroller"></A><FONT SIZE=+2>&nbsp;Sound Controller</FONT></TD></TR></TABLE><BR>
<A HREF="#soundoverview">Sound Overview</A><BR>
<A HREF="#soundchannel1tonesweep">Sound Channel 1 - Tone & Sweep</A><BR>
<A HREF="#soundchannel2tone">Sound Channel 2 - Tone</A><BR>
<A HREF="#soundchannel3waveoutput">Sound Channel 3 - Wave Output</A><BR>
<A HREF="#soundchannel4noise">Sound Channel 4 - Noise</A><BR>
<A HREF="#soundcontrolregisters">Sound Control Registers</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundoverview"></A><FONT SIZE=+2>&nbsp;Sound Overview</FONT></TD></TR></TABLE><BR>
There are two sound channels connected to the output terminals SO1 and 
SO2. There is also a input terminal Vin connected to the cartridge. It 
can be routed to either of both output terminals. GameBoy circuitry 
allows producing sound in four different ways:<BR>
<BR>
<TABLE><TR><TD><PRE>   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.
</TD></TR></TABLE><BR>
These four sounds can be controlled independantly and then mixed 
separately for each of the output terminals.<BR>
<BR>
Sound registers may be set at all times while producing sound.<BR>
<BR>
(Sounds will have a 2.4% higher frequency on Super GB.)<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel1tonesweep"></A><FONT SIZE=+2>&nbsp;Sound Channel 1 - Tone & Sweep</FONT></TD></TR></TABLE><BR>
<B>FF10 - NR10 - Channel 1 Sweep register (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)
</TD></TR></TABLE>Sweep Time:<BR>
<TABLE><TR><TD><PRE>  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)
</TD></TR></TABLE><BR>
The change of frequency (NR13,NR14) at each shift is calculated by the 
following formula where X(0) is initial freq & X(t-1) is last freq:<BR>
<TABLE><TR><TD><PRE>  X(t) = X(t-1) +/- X(t-1)/2^n
</TD></TR></TABLE><BR>
<B>FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
</TD></TR></TABLE>Wave Duty:<BR>
<TABLE><TR><TD><PRE>  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )
</TD></TR></TABLE>Sound Length = (64-t1)*(1/256) seconds<BR>
The Length value is used only if Bit 6 in NR14 is set.<BR>
<BR>
<B>FF12 - NR12 - Channel 1 Volume Envelope (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</TD></TR></TABLE>Length of 1 step = n*(1/64) seconds<BR>
<BR>
<B>FF13 - NR13 - Channel 1 Frequency lo (Write Only)<BR>
</B><BR>
Lower 8 bits of 11 bit frequency (x).<BR>
Next 3 bit are in NR14 ($FF14)<BR>
<BR>
<B>FF14 - NR14 - Channel 1 Frequency hi (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</TD></TR></TABLE>Frequency = 131072/(2048-x) Hz<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel2tone"></A><FONT SIZE=+2>&nbsp;Sound Channel 2 - Tone</FONT></TD></TR></TABLE><BR>
This sound channel works exactly as channel 1, except that it doesn't 
have a Tone Envelope/Sweep Register.<BR>
<BR>
<B>FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
</TD></TR></TABLE>Wave Duty:<BR>
<TABLE><TR><TD><PRE>  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )
</TD></TR></TABLE>Sound Length = (64-t1)*(1/256) seconds<BR>
The Length value is used only if Bit 6 in NR24 is set.<BR>
<BR>
<B>FF17 - NR22 - Channel 2 Volume Envelope (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</TD></TR></TABLE>Length of 1 step = n*(1/64) seconds<BR>
<BR>
<B>FF18 - NR23 - Channel 2 Frequency lo data (W)<BR>
</B>Frequency's lower 8 bits of 11 bit data (x).<BR>
Next 3 bits are in NR24 ($FF19).<BR>
<BR>
<B>FF19 - NR24 - Channel 2 Frequency hi data (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</TD></TR></TABLE>Frequency = 131072/(2048-x) Hz<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel3waveoutput"></A><FONT SIZE=+2>&nbsp;Sound Channel 3 - Wave Output</FONT></TD></TR></TABLE><BR>
This channel can be used to output digital sound, the length of the 
sample buffer (Wave RAM) is limited to 32 digits. This sound channel can 
be also used to output normal tones when initializing the Wave RAM by a 
square wave. This channel doesn't have a volume envelope register.<BR>
<BR>
<B>FF1A - NR30 - Channel 3 Sound on/off (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)
</TD></TR></TABLE><BR>
<B>FF1B - NR31 - Channel 3 Sound Length<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-0 - Sound length (t1: 0 - 255)
</TD></TR></TABLE>Sound Length = (256-t1)*(1/256) seconds<BR>
This value is used only if Bit 6 in NR34 is set.<BR>
<BR>
<B>FF1C - NR32 - Channel 3 Select output level (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 6-5 - Select output level (Read/Write)
</TD></TR></TABLE>Possible Output levels are:<BR>
<TABLE><TR><TD><PRE>  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)
</TD></TR></TABLE><BR>
<B>FF1D - NR33 - Channel 3 Frequency's lower data (W)<BR>
</B>Lower 8 bits of an 11 bit frequency (x).<BR>
<BR>
<B>FF1E - NR34 - Channel 3 Frequency's higher data (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</TD></TR></TABLE>Frequency  =  4194304/(64*(2048-x)) Hz  =  65536/(2048-x) Hz<BR>
<BR>
<B>FF30-FF3F - Wave Pattern RAM<BR>
</B>Contents - Waveform storage for arbitrary sound data<BR>
<BR>
This storage area holds 32 4-bit samples  that are played back upper 4 
bits first.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel4noise"></A><FONT SIZE=+2>&nbsp;Sound Channel 4 - Noise</FONT></TD></TR></TABLE><BR>
This channel is used to output white noise. This is done by randomly 
switching the amplitude between high and low at a given frequency. 
Depending on the frequency the noise will appear 'harder' or 'softer'.<BR>
<BR>
It is also possible to influence the function of the random generator, 
so the that the output becomes more regular, resulting in a limited 
ability to output Tone instead of Noise.<BR>
<BR>
<B>FF20 - NR41 - Channel 4 Sound Length (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 5-0 - Sound length data (t1: 0-63)
</TD></TR></TABLE>Sound Length = (64-t1)*(1/256) seconds<BR>
The Length value is used only if Bit 6 in NR44 is set.<BR>
<BR>
<B>FF21 - NR42 - Channel 4 Volume Envelope (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</TD></TR></TABLE>Length of 1 step = n*(1/64) seconds<BR>
<BR>
<B>FF22 - NR43 - Channel 4 Polynomial Counter (R/W)<BR>
</B>The amplitude is randomly switched between high and low at the given 
frequency. A higher frequency will make the noise to appear 'softer'.<BR>
When Bit 3 is set, the output will become more regular, and some 
frequencies will sound more like Tone than Noise.<BR>
<TABLE><TR><TD><PRE>  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)
</TD></TR></TABLE>Frequency = 524288 Hz / r / 2^(s+1)     ;For r=0 assume r=0.5 instead<BR>
<BR>
<B>FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundcontrolregisters"></A><FONT SIZE=+2>&nbsp;Sound Control Registers</FONT></TD></TR></TABLE><BR>
<B>FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)<BR>
</B>The volume bits specify the "Master Volume" for Left/Right sound output.<BR>
<TABLE><TR><TD><PRE>  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)
</TD></TR></TABLE>The Vin signal is received from the game cartridge bus, allowing 
external hardware in the cartridge to supply a fifth sound channel, 
additionally to the gameboys internal four channels. As far as I know 
this feature isn't used by any existing games.<BR>
<BR>
<B>FF25 - NR51 - Selection of Sound output terminal (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal
</TD></TR></TABLE><BR>
<B>FF26 - NR52 - Sound on/off<BR>
</B>If your GB programs don't use sound then write 00h to this register to 
save 16% or more on GB power consumption. Disabeling the sound 
controller by clearing Bit 7 destroys the contents of all sound 
registers. Also, it is not possible to access any sound registers 
(execpt FF26) while the sound controller is disabled.<BR>
<TABLE><TR><TD><PRE>  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)
</TD></TR></TABLE>Bits 0-3 of this register are read only status bits, writing to these 
bits does NOT enable/disable sound. The flags get set when sound output 
is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag 
remains set until the sound length has expired (if enabled). A volume 
envelopes which has decreased to zero volume will NOT cause the sound 
flag to go off.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="joypadinput"></A><FONT SIZE=+2>&nbsp;Joypad Input</FONT></TD></TR></TABLE><BR>
<B>FF00 - P1/JOYP - Joypad (R/W)<BR>
</B>The eight gameboy buttons/direction keys are arranged in form of a 2x4 
matrix. Select either button or direction keys by writing to this 
register, then read-out bit 0-3.<BR>
<TABLE><TR><TD><PRE>  Bit 7 - Not used
  Bit 6 - Not used
  Bit 5 - P15 Select Button Keys      (0=Select)
  Bit 4 - P14 Select Direction Keys   (0=Select)
  Bit 3 - P13 Input Down  or Start    (0=Pressed) (Read Only)
  Bit 2 - P12 Input Up    or Select   (0=Pressed) (Read Only)
  Bit 1 - P11 Input Left  or Button B (0=Pressed) (Read Only)
  Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)
</TD></TR></TABLE>Note: Most programs are repeatedly reading from this port several times 
(the first reads used as short delay, allowing the inputs to stabilize, 
and only the value from the last read actually used).<BR>
<BR>
<B>Usage in SGB software<BR>
</B>Beside for normal joypad input, SGB games mis-use the joypad register to 
output SGB command packets to the SNES, also, SGB programs may read out 
gamepad states from up to four different joypads which can be connected 
to the SNES.<BR>
See SGB description for details.<BR>
<BR>
<B>INT 60 - Joypad Interrupt<BR>
</B>Joypad interrupt is requested when any of the above Input lines changes 
from High to Low. Generally this should happen when a key becomes 
pressed (provided that the button/direction key is enabled by above 
Bit4/5), however, because of switch bounce, one or more High to Low 
transitions are usually produced both when pressing or releasing a key.<BR>
<BR>
<B>Using the Joypad Interrupt<BR>
</B>It's more or less useless for programmers, even when selecting both 
buttons and direction keys simultaneously it still cannot recognize all 
keystrokes, because in that case a bit might be already held low by a 
button key, and pressing the corresponding direction key would thus 
cause no difference. The only meaningful purpose of the keystroke 
interrupt would be to terminate STOP (low power) standby state.<BR>
Also, the joypad interrupt does not appear to work with CGB and GBA 
hardware (the STOP function can be still terminated by joypad keystrokes 
though).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="serialdatatransferlinkcable"></A><FONT SIZE=+2>&nbsp;Serial Data Transfer (Link Cable)</FONT></TD></TR></TABLE><BR>
<B>FF01 - SB - Serial transfer data (R/W)<BR>
</B>8 Bits of data to be read/written<BR>
<BR>
<B>FF02 - SC - Serial Transfer Control  (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - Transfer Start Flag (0=No Transfer, 1=Start)
  Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)
</TD></TR></TABLE>The clock signal specifies the rate at which the eight data bits in SB 
(FF01) are transferred. When the gameboy is communicating with another 
gameboy (or other computer) then either one must supply internal clock, 
and the other one must use external clock.<BR>
<BR>
<B>Internal Clock<BR>
</B>In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only 
(allowing to transfer about 1 KByte per second). In CGB Mode four 
internal clock rates are available, depending on Bit 1 of the SC 
register, and on whether the CGB Double Speed Mode is used:<BR>
<TABLE><TR><TD><PRE>    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode
</TD></TR></TABLE><BR>
<B>External Clock<BR>
</B>The external clock is typically supplied by another gameboy, but might 
be supplied by another computer (for example if connected to a PCs 
parallel port), in that case the external clock may have any speed. Even 
the old/monochrome gameboy is reported to recognizes external clocks of 
up to 500KHz. And there is no limitiation into the other direction - 
even when suppling an external clock speed of "1 bit per month", then 
the gameboy will still eagerly wait for the next bit(s) to be 
transferred. It isn't required that the clock pulses are sent at an 
regular interval either.<BR>
<BR>
<B>Timeouts<BR>
</B>When using external clock then the transfer will not complete until the 
last bit is received. In case that the second gameboy isn't supplying a 
clock signal, if it gets turned off, or if there is no second gameboy 
connected at all) then transfer will never complete. For this reason the 
transfer procedure should use a timeout counter, and abort the 
communication if no response has been received during the timeout 
interval.<BR>
<BR>
<B>Delays and Synchronization<BR>
</B>The gameboy that is using internal clock should always execute a small 
delay between each transfer, in order to ensure that the opponent 
gameboy has enough time to prepare itself for the next transfer, ie. the 
gameboy with external clock must have set its transfer start bit before 
the gameboy with internal clock starts the transfer. Alternately, the 
two gameboys could switch between internal and external clock for each 
transferred byte to ensure synchronization.<BR>
<BR>
Transfer is initiated by setting the Transfer Start Flag. This bit is 
automatically set to 0 at the end of Transfer. Reading this bit can be 
used to determine if the transfer is still active.<BR>
<BR>
<B>INT 58 - Serial Interrupt<BR>
</B>When the transfer has completed (ie. after sending/receiving 8 bits, if 
any) then an interrupt is requested by setting Bit 3 of the IF Register 
(FF0F). When that interrupt is enabled, then the Serial Interrupt vector 
at 0058 is called.<BR>
<BR>
<B>XXXXXX...<BR>
</B><BR>
Transmitting and receiving serial data is done simultaneously. The 
received data is automatically stored in SB.<BR>
<BR>
The serial I/O port on the Gameboy is a very simple setup and is crude 
compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports. 
There are no start or stop bits.<BR>
<BR>
During a transfer, a byte is shifted in at the same time that a byte is 
shifted out. The rate of the shift is determined by whether the clock 
source is internal or external.<BR>
The most significant bit is shifted in and out first.<BR>
<BR>
When the internal clock is selected, it drives the clock pin on the game 
link port and it stays high when not used. During a transfer it will go 
low eight times to clock in/out each bit.<BR>
<BR>
The state of the last bit shifted out determines the state of the output 
line until another transfer takes place.<BR>
<BR>
If a serial transfer with internal clock is performed and no external 
GameBoy is present, a value of $FF will be received in the transfer.<BR>
<BR>
The following code causes $75 to be shifted out the serial port and a 
byte to be shifted into $FF01:<BR>
<BR>
<TABLE><TR><TD><PRE>    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="timeranddividerregisters"></A><FONT SIZE=+2>&nbsp;Timer and Divider Registers</FONT></TD></TR></TABLE><BR>
<B>FF04 - DIV - Divider Register (R/W)<BR>
</B>This register is incremented at rate of 16384Hz (~16779Hz on SGB). In 
CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz. 
Writing any value to this register resets it to 00h.<BR>
<BR>
<B>FF05 - TIMA - Timer counter (R/W)<BR>
</B>This timer is incremented by a clock frequency specified by the TAC 
register ($FF07). When the value overflows (gets bigger than FFh) then 
it will be reset to the value specified in TMA (FF06), and an interrupt 
will be requested, as described below.<BR>
<BR>
<B>FF06 - TMA - Timer Modulo (R/W)<BR>
</B>When the TIMA overflows, this data will be loaded.<BR>
<BR>
<B>FF07 - TAC - Timer Control (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 2    - Timer Stop  (0=Stop, 1=Start)
  Bits 1-0 - Input Clock Select
             00:   4096 Hz    (~4194 Hz SGB)
             01: 262144 Hz  (~268400 Hz SGB)
             10:  65536 Hz   (~67110 Hz SGB)
             11:  16384 Hz   (~16780 Hz SGB)
</TD></TR></TABLE><BR>
<B>INT 50 - Timer Interrupt<BR>
</B>Each time when the timer overflows (ie. when TIMA gets bigger than FFh), 
then an interrupt is requested by setting Bit 2 in the IF Register 
(FF0F). When that interrupt is enabled, then the CPU will execute it by 
calling the timer interrupt vector at 0050h.<BR>
<BR>
<B>Note<BR>
</B>The above described Timer is the built-in timer in the gameboy. It has 
nothing to do with the MBC3s battery buffered Real Time Clock - that's a 
completely different thing, described in the chapter about Memory 
Banking Controllers.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="interrupts"></A><FONT SIZE=+2>&nbsp;Interrupts</FONT></TD></TR></TABLE><BR>
<B>IME - Interrupt Master Enable Flag (Write Only)<BR>
</B><TABLE><TR><TD><PRE>  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)
</TD></TR></TABLE>The IME flag is used to disable all interrupts, overriding any enabled 
bits in the IE Register. It isn't possible to access the IME flag by 
using a I/O address, instead IME is accessed directly from the CPU, by 
the following opcodes/operations:<BR>
<TABLE><TR><TD><PRE>  EI     ;Enable Interrupts  (ie. IME=1)
  DI     ;Disable Interrupts (ie. IME=0)
  RETI   ;Enable Ints & Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints & Call to Interrupt Vector
</TD></TR></TABLE>Whereas &lt;INT&gt; means the operation which is automatically executed by the 
CPU when it executes an interrupt.<BR>
<BR>
<B>FFFF - IE - Interrupt Enable (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)
</TD></TR></TABLE><BR>
<B>FF0F - IF - Interrupt Flag (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)
</TD></TR></TABLE>When an interrupt signal changes from low to high, then the 
corresponding bit in the IF register becomes set. For example, Bit 0 
becomes set when the LCD controller enters into the V-Blank period.<BR>
<BR>
<B>Interrupt Requests<BR>
</B>Any set bits in the IF register are only &lt;requesting&gt; an interrupt to be 
executed. The actual &lt;execution&gt; happens only if both the IME flag, and 
the corresponding bit in the IE register are set, otherwise the 
interrupt 'waits' until both IME and IE allow its execution.<BR>
<BR>
<B>Interrupt Execution<BR>
</B>When an interrupt gets executed, the corresponding bit in the IF 
register becomes automatically reset by the CPU, and the IME flag 
becomes cleared (disabeling any further interrupts until the program 
re-enables the interrupts, typically by using the RETI instruction), and 
the corresponding Interrupt Vector (that are the addresses in range 
0040h-0060h, as shown in IE and IF register decriptions above) becomes 
called.<BR>
<BR>
<B>Manually Requesting/Discarding Interrupts<BR>
</B>As the CPU automatically sets and cleares the bits in the IF register it 
is usually not required to write to the IF register. However, the user 
may still do that in order to manually request (or discard) interrupts. 
As for real interrupts, a manually requested interrupt isn't executed 
unless/until IME and IE allow its execution.<BR>
<BR>
<B>Interrupt Priorities<BR>
</B>In the following three situations it might happen that more than 1 bit 
in the IF register are set, requesting more than one interrupt at once:<BR>
<TABLE><TR><TD><PRE>  1) More than one interrupt signal changed from Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several "1" bits
     (for example 1Fh) to the IF register.
</TD></TR></TABLE>Provided that IME and IE allow the execution of more than one of the 
requested interrupts, then the interrupt with the highest priority 
becomes executed first. The priorities are ordered as the bits in the IE 
and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4 
(Joypad) having the lowest priority.<BR>
<BR>
<B>Nested Interrupts<BR>
</B>The CPU automatically disables all other interrupts by setting IME=0 
when it executes an interrupt. Usually IME remains zero until the 
interrupt procedure returns (and sets IME=1 by the RETI instruction). 
However, if you want any other interrupts of lower or higher (or same) 
priority to be allowed to be executed from inside of the interrupt 
procedure, then you can place an EI instruction into the interrupt 
procedure.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cgbregisters"></A><FONT SIZE=+2>&nbsp;CGB Registers</FONT></TD></TR></TABLE><BR>
<B>Forward<BR>
</B>This chapter describes only CGB (Color Gameboy) registers that didn't 
fit into normal categories - most CGB registers are described in the 
chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA 
Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, 
a changed bit is noted in the chapter about the Serial/Link port.<BR>
<BR>
<B>Unlocking CGB functions<BR>
</B>When using any CGB registers (including those in the Video/Link 
chapters), you must first unlock CGB features by changing byte 0143h in 
the cartridge header. Typically use a value of 80h for games which 
support both CGB and monochrome gameboys, and C0h for games which work 
on CGBs only. Otherwise, the CGB will operate in monochrome "Non CGB" 
compatibility mode.<BR>
<BR>
<B>Detecting CGB (and GBA) functions<BR>
</B>CGB hardware can be detected by examing the CPU accumulator (A-register) 
directly after startup. A value of 11h indicates CGB (or GBA) hardware, 
if so, CGB functions can be used (if unlocked, see above).<BR>
When A=11h, you may also examine Bit 0 of the CPUs B-Register to 
separate between CGB (bit cleared) and GBA (bit set), by that detection 
it is possible to use 'repaired' color palette data matching for GBA 
displays.<BR>
<BR>
<B>FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch<BR>
</B><TABLE><TR><TD><PRE>  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)
</TD></TR></TABLE>This register is used to prepare the gameboy to switch between CGB 
Double Speed Mode and Normal Speed Mode. The actual speed switch is 
performed by executing a STOP command after Bit 0 has been set. After 
that Bit 0 will be cleared automatically, and the gameboy will operate 
at the 'other' speed. The recommended speed switching procedure in 
pseudo code would be:<BR>
<TABLE><TR><TD><PRE>  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF
</TD></TR></TABLE>The CGB is operating in Normal Speed Mode when it is turned on. Note 
that using the Double Speed Mode increases the power consumption, it 
would be recommended to use Single Speed whenever possible. However, the 
display will flicker (white) for a moment during speed switches, so this 
cannot be done permanentely.<BR>
In Double Speed Mode the following will operate twice as fast as normal:<BR>
<TABLE><TR><TD><PRE>  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM
</TD></TR></TABLE>And the following will keep operating as usual:<BR>
<TABLE><TR><TD><PRE>  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies
</TD></TR></TABLE><BR>
<B>FF56 - RP - CGB Mode Only - Infrared Communications Port<BR>
</B>This register allows to input and output data through the CGBs built-in 
Infrared Port. When reading data, bit 6 and 7 must be set (and obviously 
Bit 0 must be cleared - if you don't want to receive your own gameboys 
IR signal). After sending or receiving data you should reset the 
register to 00h to reduce battery power consumption again.<BR>
<TABLE><TR><TD><PRE>  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)
</TD></TR></TABLE>Note that the receiver will adapt itself to the normal level of IR 
pollution in the air, so if you would send a LED ON signal for a longer 
period, then the receiver would treat that as normal (=OFF) after a 
while. For example, a Philips TV Remote Control sends a series of 32 LED 
ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 
880us LED ON signal.<BR>
Even though being generally CGB compatible, the GBA does not include an 
infra-red port.<BR>
<BR>
<B>FF70 - SVBK - CGB Mode Only - WRAM Bank<BR>
</B>In CGB Mode 32 KBytes internal RAM are available. This memory is divided 
into 8 banks of 4 KBytes each. Bank 0 is always available in memory at 
C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.<BR>
<TABLE><TR><TD><PRE>  Bit 0-2  Select WRAM Bank (Read/Write)
</TD></TR></TABLE>Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h 
will select Bank 1 either.<BR>
<BR>
<B>FF6C - Undocumented (FEh) - Bit 0   (Read/Write) - CGB Mode Only<BR>
FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)<BR>
FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)<BR>
FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only<BR>
FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)<BR>
FF76 - Undocumented (00h) - Always 00h (Read Only)<BR>
FF77 - Undocumented (00h) - Always 00h (Read Only)<BR>
</B>These are undocumented CGB Registers. The numbers in brackets () 
indicate the initial values. Purpose of these registers is unknown (if 
any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB 
Mode.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbfunctions"></A><FONT SIZE=+2>&nbsp;SGB Functions</FONT></TD></TR></TABLE><BR>
<B>General Information<BR>
</B><A HREF="#sgbdescription">SGB Description</A><BR>
<A HREF="#sgbunlockinganddetectingsgbfunctions">SGB Unlocking and Detecting SGB Functions</A><BR>
<A HREF="#sgbcommandpackettransfers">SGB Command Packet Transfers</A><BR>
<A HREF="#sgbvramtransfers">SGB VRAM Transfers</A><BR>
<A HREF="#sgbcommandsummary">SGB Command Summary</A><BR>
<A HREF="#sgbcolorpalettesoverview">SGB Color Palettes Overview</A><BR>
<BR>
<B>SGB Commands<BR>
</B><A HREF="#sgbpalettecommands">SGB Palette Commands</A><BR>
<A HREF="#sgbcolorattributecommands">SGB Color Attribute Commands</A><BR>
<A HREF="#sgbsoundfunctions">SGB Sound Functions</A><BR>
<A HREF="#sgbsystemcontrolcommands">SGB System Control Commands</A><BR>
<A HREF="#sgbmultiplayercommand">SGB Multiplayer Command</A><BR>
<A HREF="#sgbborderandobjcommands">SGB Border and OBJ Commands</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbdescription"></A><FONT SIZE=+2>&nbsp;SGB Description</FONT></TD></TR></TABLE><BR>
<B>General Description<BR>
</B>Basically, the SGB (Super Gameboy) is an adapter cartridge that allows 
to play gameboy games on a SNES (Super Nintendo Entertainment System) 
gaming console. In detail, you plug the gameboy cartridge into the SGB 
cartridge, then plug the SGB cartridge into the SNES, and then connect 
the SNES to your TV Set. In result, games can be played and viewed on 
the TV Set, and are controlled by using the SNES joypad(s).<BR>
<BR>
<B>More Technical Description<BR>
</B>The SGB cartridge just contains a normal gameboy CPU and normal gameboy 
video controller. Normally the video signal from this controller would 
be sent to the LCD screen, however, in this special case the SNES read 
out the video signal and displays it on the TV set by using a special 
SNES BIOS ROM which is located in the SGB cartridge. Also, normal 
gameboy sound output is forwared to the SNES and output to the TV Set, 
vice versa, joypad input is forwared from the SNES controller(s) to the 
gameboy joypad inputs.<BR>
<BR>
<B>Normal Monochrome Games<BR>
</B>Any gameboy games which have been designed for normal monochrome 
handheld gameboys will work with the SGB hardware as well. The SGB will 
apply a four color palette to these games by replacing the normal four 
grayshades. The 160x144 pixel gamescreen is displayed in the middle of 
the 256x224 pixel SNES screen (the unused area is filled by a screen 
border bitmap). The user may access built-in menues, allowing to change 
color palette data, to select between several pre-defined borders, etc.<BR>
<BR>
Games that have been designed to support SGB functions may also access 
the following additional features:<BR>
<BR>
<B>Colorized Game Screen<BR>
</B>There's limited ability to colorize the gamescreen by assigning custom 
color palettes to each 20x18 display characters, however, this works 
mainly for static display data such like title screens or status bars, 
the 20x18 color attribute map is non-scrollable, and it is not possible 
to assign separate colors to moveable foreground sprites (OBJs), so that 
animated screen regions will be typically restricted to using a single 
palette of four colors only.<BR>
<BR>
<B>SNES Foreground Sprites<BR>
</B>Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can 
be displayed. When replacing (or just overlaying) the normal gameboy 
OBJs by SNES OBJs it'd be thus possible to display OBJs with other 
colors than normal background area. This method doesn't appear to be 
very popular, even though it appears to be quite easy to implement, 
however, the bottommost character line of the gamescreen will be masked 
out because this area is used to transfer OAM data to the SNES.<BR>
<BR>
<B>The SGB Border<BR>
</B>The possibly most popular and most impressive feature is to replace the 
default SGB screen border by a custom bitmap which is stored in the game 
cartridge.<BR>
<BR>
<B>Multiple Joypads<BR>
</B>Up to four joypads can be conected to the SNES, and SGB software may 
read-out each of these joypads separately, allowing up to four players 
to play the same game simultaneously. Unlike for multiplayer handheld 
games, this requires only one game cartridge and only one SGB/SNES, and 
no link cables are required, the downside is that all players must share 
the same display screen.<BR>
<BR>
<B>Sound Functions<BR>
</B>Beside for normal gameboy sound, a number of digital sound effects is 
pre-defined in the SNES BIOS, these effects may be accessed quite 
easily. Programmers whom are familiar with SNES sounds may also access 
the SNES sound chip, or use the SNES MIDI engine directly in order to 
produce other sound effects or music.<BR>
<BR>
<B>Taking Control of the SNES CPU<BR>
</B>Finally, it is possible to write program code or data into SNES memory, 
and to execute such program code by using the SNES CPU.<BR>
<BR>
<B>SGB System Clock<BR>
</B>Because the SGB is synchronized to the SNES CPU, the gameboy system 
clock is directly chained to the SNES system clock. In result, the 
gameboy CPU, video controller, timers, and sound frequencies will be all 
operated approx 2.4% faster as by normal gameboys.<BR>
Basically, this should be no problem, and the game will just run a 
little bit faster. However sensitive musicians may notice that sound 
frequencies are a bit too high, programs that support SGB functions may 
avoid this effect by reducing frequencies of gameboy sounds when having 
detected SGB hardware.<BR>
Also, I think that I've heard that SNES models which use a 50Hz display 
refresh rate (rather than 60Hz) are resulting in respectively slower 
SGB/gameboy timings ???<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbunlockinganddetectingsgbfunctions"></A><FONT SIZE=+2>&nbsp;SGB Unlocking and Detecting SGB Functions</FONT></TD></TR></TABLE><BR>
<B>Cartridge Header<BR>
</B>SGB games are required to have a cartridge header with Nintendo and 
proper checksum just as normal gameboy games. Also, two special entries 
must be set in order to unlock SGB functions:<BR>
<TABLE><TR><TD><PRE>  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games
</TD></TR></TABLE>When these entries aren't set, the game will still work just like all 
'monochrome' gameboy games, but it cannot access any of the special SGB 
functions.<BR>
<BR>
<B>Detecting SGB hardware<BR>
</B>The recommended detection method is to send a MLT_REQ command which 
enables two (or four) joypads. A normal handheld gameboy will ignore 
this command, a SGB will now return incrementing joypad IDs each time 
when deselecting keyboard lines (see MLT_REQ description for details).<BR>
Now read-out joypad state/IDs several times, and if the ID-numbers are 
changing, then it is a SGB (a normal gameboy would typically always 
return 0Fh as ID). Finally, when not intending to use more than one 
joypad, send another MLT_REQ command in order to re-disable the 
multi-controller mode.<BR>
Detection works regardless of whether and how many joypads are 
physically connected to the SNES. However, detection works only when 
having unlocked SGB functions in the cartridge header, as described 
above. <BR>
<BR>
<B>Separating between SGB and SGB2<BR>
</B>It is also possible to separate between SGB and SGB2 models by examining 
the inital value of the accumulator (A-register) directly after startup.<BR>
<TABLE><TR><TD><PRE>  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA
</TD></TR></TABLE>Because values 01h and FFh are shared for both handhelds and SGBs, it is 
still required to use the above MLT_REQ detection procedure. As far as I 
know the SGB2 doesn't have any extra features which'd require separate 
SGB2 detection except for curiosity purposes, for example, the game 
"Tetris DX" chooses to display an alternate SGB border on SGB2s.<BR>
<BR>
Reportedly, some SGB models include link ports (just like handheld 
gameboy) (my own SGB does not have such an port), possibly this feature 
is available in SGB2-type models only ???<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcommandpackettransfers"></A><FONT SIZE=+2>&nbsp;SGB Command Packet Transfers</FONT></TD></TR></TABLE><BR>
Command packets (aka Register Files) are transferred from the gameboy to 
the SNES by using P14 and P15 output lines of the JOYPAD register 
(FF00h), these lines are normally used to select the two rows in the 
gameboy keyboard matrix (which still works).<BR>
<BR>
<B>Transferring Bits<BR>
</B>A command packet transfer must be initiated by setting both P14 and P15 
to LOW, this will reset and start the SNES packet receiving program. 
Data is then transferred (LSB first), setting P14=LOW will indicate a 
"0" bit, and setting P15=LOW will indicate a "1" bit. For example:<BR>
<TABLE><TR><TD><PRE>       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...
</TD></TR></TABLE>Data and reset pulses must be kept LOW for at least 5us. P14 and P15 
must be kept both HIGH for at least 15us between any pulses.<BR>
Obviously, it'd be no good idea to access the JOYPAD register during the 
transfer, for example, in case that your VBlank interrupt procedure 
reads-out joypad states each frame, be sure to disable that interrupt 
during the transfer (or disable only the joypad procedure by using a 
software flag).<BR>
<BR>
<B>Transferring Packets<BR>
</B>Each packet is invoked by a RESET pulse, then 128 bits of data are 
transferred (16 bytes, LSB of first byte first), and finally, a "0"-bit 
must be transferred as stop bit. The structure of normal packets is:<BR>
<TABLE><TR><TD><PRE>   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)
</TD></TR></TABLE>The above 'Length' indicates the total number of packets (1-7, including 
the first packet) which will be sent, ie. if more than 15 parameter 
bytes are used, then further packet(s) will follow, as such:<BR>
<TABLE><TR><TD><PRE>   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)
</TD></TR></TABLE>By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.<BR>
Unused bytes at the end of the last packet must be set to zero.<BR>
A 60ms (4 frames) delay should be invoked between each packet transfer.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbvramtransfers"></A><FONT SIZE=+2>&nbsp;SGB VRAM Transfers</FONT></TD></TR></TABLE><BR>
<B>Overview<BR>
</B>Beside for the packet transfer method, larger data blocks of 4KBytes can 
be transferred by using the video signal. These transfers are invoked by 
first sending one of the commands with the ending _TRN (by using normal 
packet transfer), the 4K data block is then read-out by the SNES from 
gameboy display memory during the next frame.<BR>
<BR>
<B>Transfer Data<BR>
</B>Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,<BR>
even though the SNES receives the data in from display scanlines, it 
will automatically re-produce the same ordering of bits and bytes, as 
being originally stored at 8000h-8FFFh in gameboy memory.<BR>
<BR>
<B>Preparing the Display<BR>
</B>The above method works only when recursing the following things: BG Map 
must display unsigned characters 00h-FFh on the screen; 00h..13h in 
first line, 14h..27h in next line, etc. The gameboy display must be 
enabled, the display may not be scrolled, OBJ sprites should not overlap 
the background tiles, the BGP palette register must be set to E4h.<BR>
<BR>
<B>Transfer Time<BR>
</B>Note that the transfer data should be prepared in VRAM &lt;before&gt; sending 
the transfer command packet. The actual transfer starts at the beginning 
of the next frame after the command has been sent, and the transfer ends 
at the end of the 5th frame after the command has been sent (not 
counting the frame in which the command has been sent).<BR>
<BR>
<B>Avoiding Screen Garbage<BR>
</B>The display will contain 'garbage' during the transfer, this dirt-effect 
can be avoided by freezing the screen (in the state which has been 
displayed before the transfer) by using the MASK_EN command.<BR>
Of course, this works only when actually executing the game on a SGB 
(and not on normal handheld gameboys), it'd be thus required to detect 
the presence of SGB hardware before blindly sending VRAM data.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcommandsummary"></A><FONT SIZE=+2>&nbsp;SGB Command Summary</FONT></TD></TR></TABLE><BR>
<B>SGB System Command Table<BR>
</B><TABLE><TR><TD><PRE>  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  "Block" Area Designation Mode
  05   ATTR_LIN  "Line" Area Designation Mode
  06   ATTR_DIV  "Divide" Area Designation Mode
  07   ATTR_CHR  "1CHR" Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcolorpalettesoverview"></A><FONT SIZE=+2>&nbsp;SGB Color Palettes Overview</FONT></TD></TR></TABLE><BR>
<B>Available SNES Palettes<BR>
</B>The SGB/SNES provides 8 palettes of 16 colors each, each color may be 
defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are 
used to colorize the gamescreen, only the first four colors of each of 
these palettes are used. Palettes 4-7 are used for the SGB Border, all 
16 colors of each of these palettes may be used.<BR>
<BR>
<B>Color 0 Restriction<BR>
</B>Color 0 of each of the eight palettes is transparent, causing the 
backdrop color to be displayed instead. The backdrop color is typically 
defined by the most recently color being assigned to Color 0 (regardless 
of the palette number being used for that operation).<BR>
Effectively, gamescreen palettes can have only three custom colors each, 
and SGB border palettes only 15 colors each, additionally, color 0 can 
be used for for all palettes, which will then all share the same color 
though.<BR>
<BR>
<B>Translation of Grayshades into Colors<BR>
</B>Because the SGB/SNES reads out the gameboy video controllers display 
signal, it translates the different grayshades from the signal into SNES 
colors as such:<BR>
<TABLE><TR><TD><PRE>  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3
</TD></TR></TABLE>Note that gameboy colors 0-3 are assigned to user-selectable grayshades 
by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed 
relationship between gameboy colors 0-3 and SNES colors 0-3.<BR>
<BR>
<B>Using Gameboy BGP/OBP Registers<BR>
</B>A direct translation of color 0-3 into color 0-3 may be produced by 
setting BGP/OBP registers to a value of 0E4h each. However, in case that 
your program uses black background for example, then you may internally 
assign background as "White" at the gameboy side by BGP/OBP registers 
(which is then interpreted as SNES color 0, which is shared for all SNES 
palettes). The advantage is that you may define Color 0 as Black at the 
SNES side, and may assign custom colors for Colors 1-3 of each SNES 
palette.<BR>
<BR>
<B>System Color Palette Memory<BR>
</B>Beside for the actually visible palettes, up to 512 palettes of 4 colors 
each may be defined in SNES RAM. Basically, this is completely 
irrelevant because the palettes are just stored in RAM whithout any 
relationship to the displayed picture, anyways, these pre-defined colors 
may be transferred to actually visible palettes slightly faster as when 
transferring palette data by separate command packets.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbpalettecommands"></A><FONT SIZE=+2>&nbsp;SGB Palette Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 00h - PAL01<BR>
</B>Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, 
color 1-3 (without separate color 0).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)
</TD></TR></TABLE>The value transferred as color 0 will be applied for all eight palettes.<BR>
<BR>
<B>SGB Command 01h - PAL23<BR>
</B>Same as above PAL01, but for Palettes 2 and 3 respectively.<BR>
<BR>
<B>SGB Command 02h - PAL03<BR>
</B>Same as above PAL01, but for Palettes 0 and 3 respectively.<BR>
<BR>
<B>SGB Command 03h - PAL12<BR>
</B>Same as above PAL01, but for Palettes 1 and 2 respectively.<BR>
<BR>
<B>SGB Command 0Ah - PAL_SET<BR>
</B>Used to copy pre-defined palette data from SGB system color palette to 
actual SGB palette.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)
</TD></TR></TABLE>Before using this function, System Palette data should be initialized by 
PAL_TRN command, and (when used) Attribute File data should be 
initialized by ATTR_TRN.<BR>
<BR>
<B>SGB Command 0Bh - PAL_TRN<BR>
</B>Used to initialize SGB system color palettes in SNES RAM.<BR>
System color palette memory contains 512 pre-defined palettes, these 
palettes do not directly affect the display, however, the PAL_SET 
command may be later used to transfer four of these 'logical' palettes 
to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function 
will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ 
palettes (16 colors).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The palette data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FFF  Data for System Color Palette 0-511
</TD></TR></TABLE>Each Palette consists of four 16bit-color definitions (8 bytes).<BR>
Note: The data is stored at 3000h-3FFFh in SNES memory.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcolorattributecommands"></A><FONT SIZE=+2>&nbsp;SGB Color Attribute Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 04h - ATTR_BLK<BR>
</B>Used to specify color attributes for the inside or outside of one or 
more rectangular screen regions.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)
</TD></TR></TABLE>When sending three or more data sets, data is continued in further 
packet(s). Unused bytes at the end of the last packet should be set to 
zero. The format of the separate Data Sets is described below.<BR>
<BR>
<B>SGB Command 05h - ATTR_LIN<BR>
</B>Used to specify color attributes of one or more horizontal or vertical 
character lines.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.
</TD></TR></TABLE>When sending 15 or more data sets, data is continued in further 
packet(s). Unused bytes at the end of the last packet should be set to 
zero. The format of the separate Data Sets (one byte each) is described 
below.<BR>
The length of each line reaches from one end of the screen to the other 
end. In case that some lines overlap each other, then lines from 
lastmost data sets will overwrite lines from previous data sets.<BR>
<BR>
<B>SGB Command 06h - ATTR_DIV<BR>
</B>Used to split the screen into two halfes, and to assign separate color 
attributes to each half, and to the division line between them.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)
</TD></TR></TABLE><BR>
<B>SGB Command 07h - ATTR_CHR<BR>
</B>Used to specify color attributes for separate characters.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.
</TD></TR></TABLE>When sending 41 or more data sets, data is continued in further 
packet(s). Unused bytes at the end of the last packet should be set to 
zero. Each data set consists of two bits, indicating the palette number 
for one character.<BR>
Depending on the writing style, data sets are written from left to 
right, or from top to bottom. In either case the function wraps to the 
next row/column when reaching the end of the screen.<BR>
<BR>
<B>SGB Command 15h - ATTR_TRN<BR>
</B>Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists 
of 20x18 color attributes for the gameboy screen. This function does not 
directly affect display attributes. Instead, one of the defined ATFs may 
be copied to actual display memory at a later time by using ATTR_SET or 
PAL_SET functions.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The ATF data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used
</TD></TR></TABLE>Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of 
the 18 character lines of the gameboy window. The two most significant 
bits of the first byte define the color attribute (0-3) for the first 
character of the first line, the next two bits the next character, and 
so on.<BR>
<BR>
<B>SGB Command 16h - ATTR_SET<BR>
</B>Used to transfer attributes from Attribute File (ATF) to gameboy window.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)
</TD></TR></TABLE>When above Bit 6 is set, the gameboy screen becomes re-enabled after the 
transfer (in case it has been disabled/frozen by MASK_EN command).<BR>
Note: The same functions may be (optionally) also included in PAL_SET 
commands, as described in the chapter about Color Palette Commands.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbsoundfunctions"></A><FONT SIZE=+2>&nbsp;SGB Sound Functions</FONT></TD></TR></TABLE><BR>
<B>SGB Command 08h - SOUND<BR>
</B>Used to start/stop internal sound effect, start/stop sound using 
internal tone data.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)
</TD></TR></TABLE>See Sound Effect Tables below for a list of available pre-defined effects.<BR>
"Notes"<BR>
1) Mute is only active when both bits D2 and D3 are 1.<BR>
2) When the volume is set for either Sound Effect A or Sound Effect B, 
mute is turned off.<BR>
3) When Mute on/off has been executed, the sound fades out/fades in.<BR>
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect 
A, Sound Effect B, and the Super NES APU. A "mute off" flag does not 
exist by itself. When mute flag is set, volume and pitch of Sound Effect 
A (port 1) and Sound Effect B (port 2) must be set.<BR>
<BR>
<B>SGB Command 09h - SOU_TRN<BR>
</B>Used to transfer sound code or data to SNES Audio Processing Unit memory 
(APU-RAM).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The sound code/data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used
</TD></TR></TABLE>Possible destinations in APU-RAM are:<BR>
<TABLE><TR><TD><PRE>  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)
</TD></TR></TABLE>This function may be used to take control of the SNES sound chip, and/or 
to access the SNES MIDI engine. In either case it requires deeper 
knowledge of SNES sound programming.<BR>
<BR>
<B>SGB Sound Effect A/B Tables<BR>
</B>Below lists the digital sound effects that are pre-defined in the 
SGB/SNES BIOS, and which can be used with the SGB "SOUND" Command.<BR>
Effect A and B may be simultaneously reproduced.<BR>
The P-column indicates the recommended Pitch value, the V-column 
indicates the numbers of Voices used. Sound Effect A uses voices 6,7. 
Sound Effect B uses voices 0,1,4,5. Effects that use less voices will 
use only the upper voices (eg. 4,5 for Effect B with only two voices).<BR>
<BR>
<B>Sound Effect A Flag Table<BR>
</B><TABLE><TR><TD><PRE>  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on & off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2
</TD></TR></TABLE>Sound effect A is used for formanto sounds (percussion sounds).<BR>
<BR>
<B>Sound Effect B Flag Table<BR>
</B><TABLE><TR><TD><PRE>  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2
</TD></TR></TABLE>Sound effect B is mainly used for looping sounds (sustained sounds).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbsystemcontrolcommands"></A><FONT SIZE=+2>&nbsp;SGB System Control Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 17h - MASK_EN<BR>
</B>Used to mask the gameboy window, among others this can be used to freeze 
the gameboy screen before transferring data through VRAM (the SNES then 
keeps displaying the gameboy screen, even though VRAM doesn't contain 
meaningful display information during the transfer).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)
</TD></TR></TABLE>Freezing works only if the SNES has stored a picture, ie. if necessary 
wait one or two frames before freezing (rather than freezing directly 
after having displayed the picture).<BR>
The Cancel Mask function may be also invoked (optionally) by completion 
of PAL_SET and ATTR_SET commands.<BR>
<BR>
<B>SGB Command 0Ch - ATRC_EN<BR>
</B>Used to enable/disable Attraction mode. It is totally unclear what an 
attraction mode is ???, but it is enabled by default.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)
</TD></TR></TABLE><BR>
<B>SGB Command 0Dh - TEST_EN<BR>
</B>Used to enable/disable test mode for "SGB-CPU variable clock speed 
function". This function is disabled by default.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)
</TD></TR></TABLE>Maybe intended to determine whether SNES operates at 50Hz or 60Hz 
display refresh rate ??? Possibly result can be read-out from joypad 
register ???<BR>
<BR>
<B>SGB Command 0Eh - ICON_EN<BR>
</B>Used to enable/disable ICON function. Possibly meant to enable/disable 
SGB/SNES popup menues which might otherwise activated during gameboy 
game play. By default all functions are enabled (0).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)
</TD></TR></TABLE>Above Bit 2 will suppress all further packets/commands when set, this 
might be useful when starting a monochrome game from inside of the 
SGB-menu of a multi-gamepak which contains a collection of different 
games.<BR>
<BR>
<B>SGB Command 0Fh - DATA_SND<BR>
</B>Used to write one or more bytes directly into SNES Work RAM.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.
</TD></TR></TABLE>Unused bytes at the end of the packet should be set to zero, this 
function is restricted to a single packet, so that not more than 11 
bytes can be defined at once.<BR>
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 
0000h-FFFFh.<BR>
<BR>
<B>SGB Command 10h - DATA_TRN<BR>
</B>Used to transfer binary code or data directly into SNES RAM.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)
</TD></TR></TABLE>The data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FFF  Data
</TD></TR></TABLE>Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 
0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly 
writing to the free 2KBytes at 0:1800h would be a not so good idea ???<BR>
<BR>
<B>SGB Command 12h - JUMP<BR>
</B>Used to set the SNES program counter to a specified address. Optionally, 
it may be used to set a new address for the SNES NMI handler, the NMI 
handler remains unchanged if all bytes 4-6 are zero.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero
</TD></TR></TABLE>Note: The game "Space Invaders 94" uses this function when selecting 
"Arcade mode" to execute SNES program code which has been previously 
transferred from the SGB to the SNES. The type of the CPU which is used 
in the SNES is unknown ???<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbmultiplayercommand"></A><FONT SIZE=+2>&nbsp;SGB Multiplayer Command</FONT></TD></TR></TABLE><BR>
<B>SGB Command 11h - MLT_REQ<BR>
</B>Used to request multiplayer mode (ie. input from more than one joypad).<BR>
Because this function provides feedback from the SGB/SNES to the gameboy 
program, it is also used to detect SGB hardware.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)
</TD></TR></TABLE>In one player mode, the second joypad (if any) is used for the SGB 
system program. In two player mode, both joypads are used for the game. 
Because SNES have only two joypad sockets, four player mode requires an 
external "Multiplayer 5" adapter.<BR>
<BR>
<B>Reading Multiple Controllers (Joypads)<BR>
</B>When having enabled multiple controllers by MLT_REQ, data for each 
joypad can be read out through JOYPAD register (FF00) as follows: First 
set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you 
can now read the lower 4bits of FF00 which indicate the joypad ID for 
the following joypad input:<BR>
<TABLE><TR><TD><PRE>  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4
</TD></TR></TABLE>Next, set P14 and P15 low (one after each other) to select Buttons and 
Cursor lines, and read-out joypad state as normally. When completed, set 
P14 and P15 back HIGH, this automatically increments the joypad number 
(or restarts counting once reached the lastmost joypad). Repeat the 
procedure until you have read-out states for all two (or four) joypads.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbborderandobjcommands"></A><FONT SIZE=+2>&nbsp;SGB Border and OBJ Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 13h - CHR_TRN<BR>
</B>Used to transfer tile data (characters) to SNES Tile memory in VRAM. This 
normally used to define BG tiles for the SGB Border (see PCT_TRN), but 
might be also used to define moveable SNES foreground sprites (see 
OBJ_TRN).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)
</TD></TR></TABLE>The tile data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FFF  Bitmap data for 128 Tiles
</TD></TR></TABLE>Each tile occupies 16bytes (8x8 pixels, 16 colors each).<BR>
When intending to transfer more than 128 tiles, call this function twice 
(once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ 
Bit seems to have no effect and writes to the same VRAM addresses for 
both BG and OBJ ???<BR>
<BR>
<B>SGB Command 14h - PCT_TRN<BR>
</B>Used to transfer tile map data and palette data to SNES BG Map memory in 
VRAM to be used for the SGB border. The actual tiles must be separately 
transferred by using the CHR_TRN function.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The map data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care
</TD></TR></TABLE>Each BG Map Entry consists of a 16bit value as such:<BR>
<TABLE><TR><TD><PRE>  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)
</TD></TR></TABLE>Even though 32x32 map entries are transferred, only upper 32x28 are 
actually used (256x224 pixels, SNES screen size). The 20x18 entries in 
the center of the 32x28 area should be set to 0000h as transparent space 
for the gameboy window to be displayed inside. Reportedly, 
non-transparent border data will cover the gameboy window.<BR>
<BR>
<B>SGB Command 18h - OBJ_TRN<BR>
</B>Used to transfer OBJ attributes to SNES OAM memory. Unlike all other 
functions with the ending _TRN, this function does not use the usual 
one-shot 4KBytes VRAM transfer method.<BR>
Instead, when enabled (below execute bit set), data is permanently (each 
frame) read out from the lower character line of the gameboy screen. To 
suppress garbage on the display, the lower line is masked, and only the 
upper 20x17 characters of the gameboy window are used - the masking 
method is unknwon - frozen, black, or recommended to be covered by the 
SGB border, or else ??? Also, when the function is enabled, "system 
attract mode is not performed" - whatever that means ???<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)
</TD></TR></TABLE>The recommended method is to "display" gameboy BG tiles F9h..FFh from 
left to right as first 7 characters of the bottom-most character line of 
the gameboy screen. As for normal 4KByte VRAM transfers, this area 
should not be scrolled, should not be overlapped by gameboy OBJs, and 
the gameboy BGP palette register should be set up properly. By following 
that method, SNES OAM data can be defined in the 70h bytes of the 
gameboy BG tile memory at following addresses:<BR>
<TABLE><TR><TD><PRE>  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)
</TD></TR></TABLE>The format of SNES OAM Entries is:<BR>
<TABLE><TR><TD><PRE>  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)
</TD></TR></TABLE>The format of SNES OAM MSB Entries is:<BR>
<TABLE><TR><TD><PRE>  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cpuregistersandflags"></A><FONT SIZE=+2>&nbsp;CPU Registers and Flags</FONT></TD></TR></TABLE><BR>
<B>Registers<BR>
</B><TABLE><TR><TD><PRE>  16bit Hi   Lo   Name/Function
  AF    A    -    Accumulator & Flags
  BC    B    C    BC
  DE    D    E    DE
  HL    H    L    HL
  SP    -    -    Stack Pointer
  PC    -    -    Program Counter/Pointer
</TD></TR></TABLE>As shown above, most registers can be accessed either as one 16bit 
register, or as two separate 8bit registers.<BR>
<BR>
<B>The Flag Register (lower 8bit of AF register)<BR>
</B><TABLE><TR><TD><PRE>  Bit  Name  Set Clr  Expl.
  7    zf    Z   NZ   Zero Flag
  6    n     -   -    Add/Sub-Flag (BCD)
  5    h     -   -    Half Carry Flag (BCD)
  4    cy    C   NC   Carry Flag
  3-0  -     -   -    Not used (always zero)
</TD></TR></TABLE>Conatins the result from the recent instruction which has affected 
flags.<BR>
<BR>
<B>The Zero Flag (Z)<BR>
</B>This bit becomes set (1) if the result of an operation has been zero 
(0). Used for conditional jumps.<BR>
<BR>
<B>The Carry Flag (C, or Cy)<BR>
</B>Becomes set when the result of an addition became bigger than FFh (8bit) 
or FFFFh (16bit). Or when the result of a subtraction or comparision 
became less than zero (much as for Z80 and 80x86 CPUs, but unlike as for 
65XX and ARM CPUs). Also the flag becomes set when a rotate/shift 
operation has shifted-out a "1"-bit.<BR>
Used for conditional jumps, and for instructions such like ADC, SBC, RL, 
RLA, etc.<BR>
<BR>
<B>The BCD Flags (N, H)<BR>
</B>These flags are (rarely) used for the DAA instruction only, N Indicates 
whether the previous instruction has been an addition or subtraction, 
and H indicates carry for lower 4bits of the result, also for DAA, the C 
flag must indicate carry for upper 8bits.<BR>
After adding/subtracting two BCD numbers, DAA is intended to convert the 
result into BCD format; BCD numbers are ranged from 00h to 99h rather 
than 00h to FFh.<BR>
Because C and H flags must contain carry-outs for each digit, DAA cannot 
be used for 16bit operations (which have 4 digits), or for INC/DEC 
operations (which do not affect C-flag).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cpuinstructionset"></A><FONT SIZE=+2>&nbsp;CPU Instruction Set</FONT></TD></TR></TABLE><BR>
Tables below specify the mnemonic, opcode bytes, clock cycles, affected 
flags (ordered as znhc), and explanatation.<BR>
The timings assume a CPU clock frequency of 4.194304 MHz (or 8.4<BR>
MHz for CGB in double speed mode), as all gameboy timings are divideable<BR>
by 4, many people specify timings and clock frequency divided by 4.<BR>
<BR>
<B>GMB 8bit-Loadcommands<BR>
</B><TABLE><TR><TD><PRE>  ld   r,r         xx         4 ---- r=r
  ld   r,n         xx nn      8 ---- r=n
  ld   r,(HL)      xx         8 ---- r=(HL)
  ld   (HL),r      7x         8 ---- (HL)=r
  ld   (HL),n      36 nn     12 ----
  ld   A,(BC)      0A         8 ----
  ld   A,(DE)      1A         8 ----
  ld   A,(nn)      FA        16 ----
  ld   (BC),A      02         8 ----
  ld   (DE),A      12         8 ----
  ld   (nn),A      EA        16 ----
  ld   A,(FF00+n)  F0 nn     12 ---- read from io-port n (memory FF00+n)
  ld   (FF00+n),A  E0 nn     12 ---- write to io-port n (memory FF00+n)
  ld   A,(FF00+C)  F2         8 ---- read from io-port C (memory FF00+C)
  ld   (FF00+C),A  E2         8 ---- write to io-port C (memory FF00+C)
  ldi  (HL),A      22         8 ---- (HL)=A, HL=HL+1
  ldi  A,(HL)      2A         8 ---- A=(HL), HL=HL+1
  ldd  (HL),A      32         8 ---- (HL)=A, HL=HL-1
  ldd  A,(HL)      3A         8 ---- A=(HL), HL=HL-1
</TD></TR></TABLE><BR>
<B>GMB 16bit-Loadcommands<BR>
</B><TABLE><TR><TD><PRE>  ld   rr,nn       x1 nn nn  12 ---- rr=nn (rr may be BC,DE,HL or SP)
  ld   SP,HL       F9         8 ---- SP=HL
  push rr          x5        16 ---- SP=SP-2  (SP)=rr   (rr may be BC,DE,HL,AF)
  pop  rr          x1        12 (AF) rr=(SP)  SP=SP+2   (rr may be BC,DE,HL,AF)
</TD></TR></TABLE><BR>
<B>GMB 8bit-Arithmetic/logical Commands<BR>
</B><TABLE><TR><TD><PRE>  add  A,r         8x         4 z0hc A=A+r
  add  A,n         C6 nn      8 z0hc A=A+n
  add  A,(HL)      86         8 z0hc A=A+(HL)
  adc  A,r         8x         4 z0hc A=A+r+cy
  adc  A,n         CE nn      8 z0hc A=A+n+cy
  adc  A,(HL)      8E         8 z0hc A=A+(HL)+cy
  sub  r           9x         4 z1hc A=A-r
  sub  n           D6 nn      8 z1hc A=A-n
  sub  (HL)        96         8 z1hc A=A-(HL)
  sbc  A,r         9x         4 z1hc A=A-r-cy
  sbc  A,n         DE nn      8 z1hc A=A-n-cy
  sbc  A,(HL)      9E         8 z1hc A=A-(HL)-cy
  and  r           Ax         4 z010 A=A & r
  and  n           E6 nn      8 z010 A=A & n
  and  (HL)        A6         8 z010 A=A & (HL)
  xor  r           Ax         4 z000
  xor  n           EE nn      8 z000
  xor  (HL)        AE         8 z000
  or   r           Bx         4 z000 A=A | r
  or   n           F6 nn      8 z000 A=A | n
  or   (HL)        B6         8 z000 A=A | (HL)
  cp   r           Bx         4 z1hc compare A-r
  cp   n           FE nn      8 z1hc compare A-n
  cp   (HL)        BE         8 z1hc compare A-(HL)
  inc  r           xx         4 z0h- r=r+1
  inc  (HL)        34        12 z0h- (HL)=(HL)+1
  dec  r           xx         4 z1h- r=r-1
  dec  (HL)        35        12 z1h- (HL)=(HL)-1
  daa              27         4 z-0x decimal adjust akku
  cpl              2F         4 -11- A = A xor FF
</TD></TR></TABLE><BR>
<B>GMB 16bit-Arithmetic/logical Commands<BR>
</B><TABLE><TR><TD><PRE>  add  HL,rr     x9           8 -0hc HL = HL+rr     ;rr may be BC,DE,HL,SP
  inc  rr        x3           8 ---- rr = rr+1      ;rr may be BC,DE,HL,SP
  dec  rr        xB           8 ---- rr = rr-1      ;rr may be BC,DE,HL,SP
  add  SP,dd     E8          16 00hc SP = SP +/- dd ;dd is 8bit signed number
  ld   HL,SP+dd  F8          12 00hc HL = SP +/- dd ;dd is 8bit signed number
</TD></TR></TABLE><BR>
<B>GMB Rotate- und Shift-Commands<BR>
</B><TABLE><TR><TD><PRE>  rlca           07           4 000c rotate akku left
  rla            17           4 000c rotate akku left through carry
  rrca           0F           4 000c rotate akku right
  rra            1F           4 000c rotate akku right through carry
  rlc  r         CB 0x        8 z00c rotate left
  rlc  (HL)      CB 06       16 z00c rotate left
  rl   r         CB 1x        8 z00c rotate left through carry
  rl   (HL)      CB 16       16 z00c rotate left through carry
  rrc  r         CB 0x        8 z00c rotate right
  rrc  (HL)      CB 0E       16 z00c rotate right
  rr   r         CB 1x        8 z00c rotate right through carry
  rr   (HL)      CB 1E       16 z00c rotate right through carry
  sla  r         CB 2x        8 z00c shift left arithmetic (b0=0)
  sla  (HL)      CB 26       16 z00c shift left arithmetic (b0=0)
  swap r         CB 3x        8 z000 exchange low/hi-nibble
  swap (HL)      CB 36       16 z000 exchange low/hi-nibble
  sra  r         CB 2x        8 z00c shift right arithmetic (b7=b7)
  sra  (HL)      CB 2E       16 z00c shift right arithmetic (b7=b7)
  srl  r         CB 3x        8 z00c shift right logical (b7=0)
  srl  (HL)      CB 3E       16 z00c shift right logical (b7=0)
</TD></TR></TABLE><BR>
<B>GMB Singlebit Operation Commands<BR>
</B><TABLE><TR><TD><PRE>  bit  n,r       CB xx        8 z01- test bit n
  bit  n,(HL)    CB xx       12 z01- test bit n
  set  n,r       CB xx        8 ---- set bit n
  set  n,(HL)    CB xx       16 ---- set bit n
  res  n,r       CB xx        8 ---- reset bit n
  res  n,(HL)    CB xx       16 ---- reset bit n
</TD></TR></TABLE><BR>
<B>GMB CPU-Controlcommands<BR>
</B><TABLE><TR><TD><PRE>  ccf            3F           4 -00c cy=cy xor 1
  scf            37           4 -001 cy=1
  nop            00           4 ---- no operation
  halt           76         N*4 ---- halt until interrupt occurs (low power)
  stop           10 00        ? ---- low power standby mode (VERY low power)
  di             F3           4 ---- disable interrupts, IME=0
  ei             FB           4 ---- enable interrupts, IME=1
</TD></TR></TABLE><BR>
<B>GMB Jumpcommands<BR>
</B><TABLE><TR><TD><PRE>  jp   nn        C3 nn nn    16 ---- jump to nn, PC=nn
  jp   HL        E9           4 ---- jump to HL, PC=HL
  jp   f,nn      xx nn nn 16;12 ---- conditional jump if nz,z,nc,c
  jr   PC+dd     18 dd       12 ---- relative jump to nn (PC=PC+/-7bit)
  jr   f,PC+dd   xx dd     12;8 ---- conditional relative jump if nz,z,nc,c
  call nn        CD nn nn    24 ---- call to nn, SP=SP-2, (SP)=PC, PC=nn
  call f,nn      xx nn nn 24;12 ---- conditional call if nz,z,nc,c
  ret            C9          16 ---- return, PC=(SP), SP=SP+2
  ret  f         xx        20;8 ---- conditional return if nz,z,nc,c
  reti           D9          16 ---- return and enable interrupts (IME=1)
  rst  n         xx          16 ---- call to 00,08,10,18,20,28,30,38
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cpucomparisionwithz80"></A><FONT SIZE=+2>&nbsp;CPU Comparision with Z80</FONT></TD></TR></TABLE><BR>
<B>Comparision with 8080<BR>
</B>Basically, the gameboy CPU works more like an older 8080 CPU rather than 
like a more powerful Z80 CPU. It is, however, supporting CB-prefixed 
instructions. Also, all known gameboy assemblers using the more obvious 
Z80-style syntax, rather than the chaotic 8080-style syntax.<BR>
<BR>
<B>Comparision with Z80<BR>
</B>Any DD-, ED-, and FD-prefixed instructions are missing, that means no 
IX-, IY-registers, no block commands, and some other missing commands.<BR>
All exchange instructions have been removed (including total absence of 
second register set), 16bit memory accesses are mostly missing, and 
16bit arithmetic functions are heavily cut-down.<BR>
The gameboy has no IN/OUT instructions, instead I/O ports are accessed 
directly by normal LD instructions, or by special LD (FF00+n) opcodes.<BR>
The sign and parity/overflow flags have been removed.<BR>
The gameboy operates approximately as fast as a 4MHz Z80 (8MHz in CGB 
double speed mode), execution time of all instructions has been rounded 
up to a multiple of 4 cycles though.<BR>
<BR>
<B>Moved, Removed, and Added Opcodes<BR>
</B><TABLE><TR><TD><PRE>  Opcode  Z80             GMB
  ---------------------------------------
  08      EX   AF,AF      LD   (nn),SP
  10      DJNZ PC+dd      STOP
  22      LD   (nn),HL    LDI  (HL),A
  2A      LD   HL,(nn)    LDI  A,(HL)
  32      LD   (nn),A     LDD  (HL),A
  3A      LD   A,(nn)     LDD  A,(HL)
  D3      OUT  (n),A      -
  D9      EXX             RETI
  DB      IN   A,(n)      -
  DD      &lt;IX&gt;            -
  E0      RET  PO         LD   (FF00+n),A
  E2      JP   PO,nn      LD   (FF00+C),A
  E3      EX   (SP),HL    -
  E4      CALL P0,nn      -
  E8      RET  PE         ADD  SP,dd
  EA      JP   PE,nn      LD   (nn),A
  EB      EX   DE,HL      -
  EC      CALL PE,nn      -
  ED      &lt;pref&gt;          -
  F0      RET  P          LD   A,(FF00+n)
  F2      JP   P,nn       LD   A,(FF00+C)
  F4      CALL P,nn       -
  F8      RET  M          LD   HL,SP+dd
  FA      JP   M,nn       LD   A,(nn)
  FC      CALL M,nn       -
  FD      &lt;IY&gt;            -
  CB3X    SLL  r/(HL)     SWAP r/(HL)
</TD></TR></TABLE>Note: The unused (-) opcodes will lock-up the gameboy CPU when used.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="thecartridgeheader"></A><FONT SIZE=+2>&nbsp;The Cartridge Header</FONT></TD></TR></TABLE><BR>
An internal information area is located at 0100-014F in<BR>
each cartridge. It contains the following values:<BR>
<BR>
<B>0100-0103 - Entry Point<BR>
</B>After displaying the Nintendo Logo, the built-in boot procedure jumps to 
this address (100h), which should then jump to the actual main program 
in the cartridge. Usually this 4 byte area contains a NOP instruction, 
followed by a JP 0150h instruction. But not always.<BR>
<BR>
<B>0104-0133 - Nintendo Logo<BR>
</B>These bytes define the bitmap of the Nintendo logo that is displayed 
when the gameboy gets turned on. The hexdump of this bitmap is:<BR>
<TABLE><TR><TD><PRE>  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E
</TD></TR></TABLE>The gameboys boot procedure verifies the content of this bitmap (after 
it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. 
A CGB verifies only the first 18h bytes of the bitmap, but others (for 
example a pocket gameboy) verify all 30h bytes.<BR>
<BR>
<B>0134-0143 - Title<BR>
</B>Title of the game in UPPER CASE ASCII. If it is less than 16 characters 
then the remaining bytes are filled with 00's. When inventing the CGB, 
Nintendo has reduced the length of this area to 15 characters, and some 
months later they had the fantastic idea to reduce it to 11 characters 
only. The new meaning of the ex-title bytes is described below.<BR>
<BR>
<B>013F-0142 - Manufacturer Code<BR>
</B>In older cartridges this area has been part of the Title (see above), in 
newer cartridges this area contains an 4 character uppercase 
manufacturer code. Purpose and Deeper Meaning unknown.<BR>
<BR>
<B>0143 - CGB Flag<BR>
</B>In older cartridges this byte has been part of the Title (see above). In 
CGB cartridges the upper bit is used to enable CGB functions. This is 
required, otherwise the CGB switches itself into Non-CGB-Mode. Typical 
values are:<BR>
<TABLE><TR><TD><PRE>  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).
</TD></TR></TABLE>Values with Bit 7 set, and either Bit 2 or 3 set, will switch the 
gameboy into a special non-CGB-mode with uninitialized palettes. Purpose 
unknown, eventually this has been supposed to be used to colorize 
monochrome games that include fixed palette data at a special location 
in ROM.<BR>
<BR>
<B>0144-0145 - New Licensee Code<BR>
</B>Specifies a two character ASCII licensee code, indicating the company or 
publisher of the game. These two bytes are used in newer games only 
(games that have been released after the SGB has been invented). Older 
games are using the header entry at 014B instead.<BR>
<BR>
<B>0146 - SGB Flag<BR>
</B>Specifies whether the game supports SGB functions, common values are:<BR>
<TABLE><TR><TD><PRE>  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions
</TD></TR></TABLE>The SGB disables its SGB functions if this byte is set to another value 
than 03h.<BR>
<BR>
<B>0147 - Cartridge Type<BR>
</B>Specifies which Memory Bank Controller (if any) is used in the 
cartridge, and if further external hardware exists in the cartridge.<BR>
<TABLE><TR><TD><PRE>  00h  ROM ONLY                 13h  MBC3+RAM+BATTERY
  01h  MBC1                     15h  MBC4
  02h  MBC1+RAM                 16h  MBC4+RAM
  03h  MBC1+RAM+BATTERY         17h  MBC4+RAM+BATTERY
  05h  MBC2                     19h  MBC5
  06h  MBC2+BATTERY             1Ah  MBC5+RAM
  08h  ROM+RAM                  1Bh  MBC5+RAM+BATTERY
  09h  ROM+RAM+BATTERY          1Ch  MBC5+RUMBLE
  0Bh  MMM01                    1Dh  MBC5+RUMBLE+RAM
  0Ch  MMM01+RAM                1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Dh  MMM01+RAM+BATTERY        FCh  POCKET CAMERA
  0Fh  MBC3+TIMER+BATTERY       FDh  BANDAI TAMA5
  10h  MBC3+TIMER+RAM+BATTERY   FEh  HuC3
  11h  MBC3                     FFh  HuC1+RAM+BATTERY
  12h  MBC3+RAM
</TD></TR></TABLE><BR>
<B>0148 - ROM Size<BR>
</B>Specifies the ROM Size of the cartridge. Typically calculated as "32KB 
shl N".<BR>
<TABLE><TR><TD><PRE>  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)
</TD></TR></TABLE><BR>
<B>0149 - RAM Size<BR>
</B>Specifies the size of the external RAM in the cartridge (if any).<BR>
<TABLE><TR><TD><PRE>  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
</TD></TR></TABLE>When using a MBC2 chip 00h must be specified in this entry, even though 
the MBC2 includes a built-in RAM of 512 x 4 bits.<BR>
<BR>
<B>014A - Destination Code<BR>
</B>Specifies if this version of the game is supposed to be sold in japan, 
or anywhere else. Only two values are defined.<BR>
<TABLE><TR><TD><PRE>  00h - Japanese
  01h - Non-Japanese
</TD></TR></TABLE><BR>
<B>014B - Old Licensee Code<BR>
</B>Specifies the games company/publisher code in range 00-FFh. A value of 
33h signalizes that the New License Code in header bytes 0144-0145 is 
used instead.<BR>
(Super GameBoy functions won't work if &lt;&gt; $33.)<BR>
<BR>
<B>014C - Mask ROM Version number<BR>
</B>Specifies the version number of the game. That is usually 00h.<BR>
<BR>
<B>014D - Header Checksum<BR>
</B>Contains an 8 bit checksum across the cartridge header bytes 0134-014C. 
The checksum is calculated as follows:<BR>
<TABLE><TR><TD><PRE>  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT
</TD></TR></TABLE>The lower 8 bits of the result must be the same than the value in this 
entry. The GAME WON'T WORK if this checksum is incorrect.<BR>
<BR>
<B>014E-014F - Global Checksum<BR>
</B>Contains a 16 bit checksum (upper byte first) across the whole cartridge 
ROM. Produced by adding all bytes of the cartridge (except for the two 
checksum bytes). The Gameboy doesn't verify this checksum.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="memorybankcontrollers"></A><FONT SIZE=+2>&nbsp;Memory Bank Controllers</FONT></TD></TR></TABLE><BR>
As the gameboys 16 bit address bus offers only limited space for ROM and 
RAM addressing, many games are using Memory Bank Controllers (MBCs) to 
expand the available address space by bank switching. These MBC chips 
are located in the game cartridge (ie. not in the gameboy itself), 
several different MBC types are available:<BR>
<BR>
<A HREF="#none32kbyteromonly">None (32KByte ROM only)</A><BR>
<A HREF="#mbc1max2mbyteromandor32kbyteram">MBC1 (max 2MByte ROM and/or 32KByte RAM)</A><BR>
<A HREF="#mbc2max256kbyteromand512x4bitsram">MBC2 (max 256KByte ROM and 512x4 bits RAM)</A><BR>
<A HREF="#mbc3max2mbyteromandor32kbyteramandtimer">MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer)</A><BR>
<A HREF="#huc1mbcwithinfraredcontroller">HuC1 (MBC with Infrared Controller)</A><BR>
<BR>
<A HREF="#mbctimingissues">MBC Timing Issues</A><BR>
<BR>
In each cartridge, the required (or preferred) MBC type should be 
specified in byte at 0147h of the ROM. (As described in the chapter 
about The Cartridge Header.)<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="none32kbyteromonly"></A><FONT SIZE=+2>&nbsp;None (32KByte ROM only)</FONT></TD></TR></TABLE><BR>
Small games of not more than 32KBytes ROM do not require a MBC chip for 
ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. 
Optionally up to 8KByte of RAM could be connected at A000-BFFF, even 
though that could require a tiny MBC-like circuit, but no real MBC chip.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbc1max2mbyteromandor32kbyteram"></A><FONT SIZE=+2>&nbsp;MBC1 (max 2MByte ROM and/or 32KByte RAM)</FONT></TD></TR></TABLE><BR>
This is the first MBC chip for the gameboy. Any newer MBC chips are 
working similiar, so that is relative easy to upgrade a program from one 
MBC chip to another - or even to make it compatible to several different 
types of MBCs.<BR>
<BR>
Note that the memory in range 0000-7FFF is used for both reading from 
ROM, and for writing to the MBCs Control Registers.<BR>
<BR>
<B>0000-3FFF - ROM Bank 00 (Read Only)<BR>
</B>This area always contains the first 16KBytes of the cartridge ROM.<BR>
<BR>
<B>4000-7FFF - ROM Bank 01-7F (Read Only)<BR>
</B>This area may contain any of the further 16KByte banks of the ROM, 
allowing to address up to 125 ROM Banks (almost 2MByte). As described 
below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the 
odd amount of 125 banks.<BR>
<BR>
<B>A000-BFFF - RAM Bank 00-03, if any (Read/Write)<BR>
</B>This area is used to address external RAM in the cartridge (if any). 
External RAM is often battery buffered, allowing to store game positions 
or high score tables, even if the gameboy is turned off, or if the 
cartridge is removed from the gameboy. Available RAM sizes are: 2KByte 
(at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K 
banks at A000-BFFF).<BR>
<BR>
<B>0000-1FFF - RAM Enable (Write Only)<BR>
</B>Before external RAM can be read or written, it must be enabled by 
writing to this address space. It is recommended to disable external RAM 
after accessing it, in order to protect its contents from damage during 
power down of the gameboy. Usually the following values are used:<BR>
<TABLE><TR><TD><PRE>  00h  Disable RAM (default)
  0Ah  Enable RAM
</TD></TR></TABLE>Practically any value with 0Ah in the lower 4 bits enables RAM, and any 
other value disables RAM.<BR>
<BR>
<B>2000-3FFF - ROM Bank Number (Write Only)<BR>
</B>Writing to this address space selects the lower 5 bits of the ROM Bank 
Number (in range 01-1Fh). When 00h is written, the MBC translates that 
to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be 
always directly accessed by reading from 0000-3FFF.<BR>
But (when using the register below to specify the upper ROM Bank bits), 
the same happens for Bank 20h, 40h, and 60h. Any attempt to address 
these ROM Banks will select Bank 21h, 41h, and 61h instead.<BR>
<BR>
<B>4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)<BRBR>
</B>This 2bit register can be used to select a RAM Bank in range from 
00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank 
number, depending on the current ROM/RAM Mode. (See below.)<BR>
<BR>
<B>6000-7FFF - ROM/RAM Mode Select (Write Only)<BR>
</B>This 1bit Register selects whether the two bits of the above register 
should be used as upper two bits of the ROM Bank, or as RAM Bank Number.<BR>
<TABLE><TR><TD><PRE>  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)
</TD></TR></TABLE>The program may freely switch between both modes, the only limitiation 
is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 
00-1Fh can be used during Mode 1.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbc2max256kbyteromand512x4bitsram"></A><FONT SIZE=+2>&nbsp;MBC2 (max 256KByte ROM and 512x4 bits RAM)</FONT></TD></TR></TABLE><BR>
<B>0000-3FFF - ROM Bank 00 (Read Only)<BR>
</B>Same as for MBC1.<BR>
<BR>
<B>4000-7FFF - ROM Bank 01-0F (Read Only)<BR>
</B>Same as for MBC1, but only a total of 16 ROM banks is supported.<BR>
<BR>
<B>A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)<BR>
</B>The MBC2 doesn't support external RAM, instead it includes 512x4 bits of 
built-in RAM (in the MBC2 chip itself). It still requires an external 
battery to save data during power-off though.<BR>
As the data consists of 4bit values, only the lower 4 bits of the 
"bytes" in this memory area are used.<BR>
<BR>
<B>0000-1FFF - RAM Enable (Write Only)<BR>
</B>The least significant bit of the upper address byte must be zero to 
enable/disable cart RAM. For example the following addresses can be used 
to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 
1E00-1EFF.<BR>
The suggested address range to use for MBC2 ram enable/disable is 
0000-00FF.<BR>
<BR>
<B>2000-3FFF - ROM Bank Number (Write Only)<BR>
</B>Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 
2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.<BR>
<BR>
The least significant bit of the upper address byte must be one to 
select a ROM bank. For example the following addresses can be used to 
select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.<BR>
The suggested address range to use for MBC2 rom bank selection is 
2100-21FF.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbc3max2mbyteromandor32kbyteramandtimer"></A><FONT SIZE=+2>&nbsp;MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer)</FONT></TD></TR></TABLE><BR>
Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM 
(4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The 
RTC requires an external 32.768 kHz Quartz Oscillator, and an external 
battery (if it should continue to tick when the gameboy is turned off).<BR>
<BR>
<B>0000-3FFF - ROM Bank 00 (Read Only)<BR>
</B>Same as for MBC1.<BR>
<BR>
<B>4000-7FFF - ROM Bank 01-7F (Read Only)<BR>
</B>Same as for MBC1, except that accessing banks 20h, 40h, and 60h is 
supported now.<BR>
<BR>
<B>A000-BFFF - RAM Bank 00-03, if any (Read/Write)<BR>
A000-BFFF - RTC Register 08-0C (Read/Write)<BR>
</B>Depending on the current Bank Number/RTC Register selection (see below), 
this memory space is used to access an 8KByte external RAM Bank, or a 
single RTC Register.<BR>
<BR>
<B>0000-1FFF - RAM and Timer Enable (Write Only)<BR>
</B>Mostly the same as for MBC1, a value of 0Ah will enable reading and 
writing to external RAM - and to the RTC Registers! A value of 00h will 
disable either.<BR>
<BR>
<B>2000-3FFF - ROM Bank Number (Write Only)<BR>
</B>Same as for MBC1, except that the whole 7 bits of the RAM Bank Number 
are written directly to this address. As for the MBC1, writing a value 
of 00h, will select Bank 01h instead. All other values 01-7Fh select the 
corresponding ROM Banks.<BR>
<BR>
<B>4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)<BR>
</B>As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h 
maps the corresponding external RAM Bank (if any) into memory at 
A000-BFFF.<BR>
When writing a value of 08h-0Ch, this will map the corresponding RTC 
register into memory at A000-BFFF. That register could then be 
read/written by accessing any address in that area, typically that is 
done by using address A000.<BR>
<BR>
<B>6000-7FFF - Latch Clock Data (Write Only)<BR>
</B>When writing 00h, and then 01h to this register, the current time 
becomes latched into the RTC registers. The latched data will not change 
until it becomes latched again, by repeating the write 00h-&gt;01h 
procedure.<BR>
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to 
read the latched (frozen) time from the RTC registers, while the clock 
itself continues to tick in background.<BR>
<BR>
<B>The Clock Counter Registers<BR>
</B><TABLE><TR><TD><PRE>  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)
</TD></TR></TABLE>The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC 
Registers.<BR>
<BR>
<B>The Day Counter<BR>
</B>The total 9 bits of the Day Counter allow to count days in range from 
0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value 
overflows. In that case the Carry Bit remains set until the program does 
reset it.<BR>
Note that you can store an offset to the Day Counter in battery RAM. For 
example, every time you read a non-zero Day Counter, add this Counter to 
the offset in RAM, and reset the Counter to zero. This method allows to 
count any number of days, making your program Year-10000-Proof, provided 
that the cartridge gets used at least every 511 days.<BR>
<BR>
<B>Delays<BR>
</B>When accessing the RTC Registers it is recommended to execute a 4ms 
delay (4 Cycles in Normal Speed Mode) between the separate accesses.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="huc1mbcwithinfraredcontroller"></A><FONT SIZE=+2>&nbsp;HuC1 (MBC with Infrared Controller)</FONT></TD></TR></TABLE><BR>
This controller (made by Hudson Soft) appears to be very similar to an 
MBC1 with the main difference being that it supports infrared LED input 
/ output. (Similiar to the infrared port that has been later invented in 
CGBs.)<BR>
<BR>
The Japanese cart "Fighting Phoenix" (internal cart name: SUPER B DAMAN) 
is known to contain this chip.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbctimingissues"></A><FONT SIZE=+2>&nbsp;MBC Timing Issues</FONT></TD></TR></TABLE><BR>
<B>Using MBCs with CGB Double Speed Mode<BR>
</B>The MBC5 has been designed to support CGB Double Speed Mode.<BR>
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast 
enough in that mode. If so, it might be nethertheless possible to use 
Double Speed during periods which use only code and data which is 
located in internal RAM.<BR>
However, despite of the above, my own good old selfmade MBC1-EPROM card 
appears to work stable and fine even in Double Speed Mode though.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="gamegeniesharkcheats"></A><FONT SIZE=+2>&nbsp;Gamegenie/Shark Cheats</FONT></TD></TR></TABLE><BR>
Game Shark and Gamegenie are external cartridge adapters that can be 
plugged between the gameboy and the actual game cartridge. Hexadecimal 
codes can be then entered for specific games, typically providing things 
like Infinite Sex, 255 Cigarettes, or Starting directly in Wonderland 
Level PRO, etc.<BR>
<BR>
<B>Gamegenie (ROM patches)<BR>
</B>Gamegenie codes consist of nine-digit hex numbers, formatted as 
ABC-DEF-GHI, the meaning of the separate digits is:<BR>
<TABLE><TR><TD><PRE>  AB    New data
  FCDE  Memory address, XORed by 0F000h
  GI    Old data, XORed by 0BAh and rotated left by two
  H     Don't know, maybe checksum and/or else
</TD></TR></TABLE>The address should be located in ROM area 0000h-7FFFh, the adapter 
permanently compares address/old data with address/data being read by 
the game, and replaces that data by new data if necessary. That method 
(more or less) prohibits unwanted patching of wrong memory banks. 
Eventually it is also possible to patch external RAM ?<BR>
Newer devices reportedly allow to specify only the first six digits 
(optionally). As far as I rememeber, around three or four codes can be 
used simultaneously.<BR>
<BR>
<B>Game Shark (RAM patches)<BR>
</B>Game Shark codes consist of eight-digit hex numbers, formatted as 
ABCDEFGH, the meaning of the separate digits is:<BR>
<TABLE><TR><TD><PRE>  AB    External RAM bank number
  CD    New Data
  GHEF  Memory Address (internal or external RAM, A000-DFFF)
</TD></TR></TABLE>
As far as I understand, patching is implement by hooking the original VBlank interrupt handler, and re-writing
RAM values each frame. The downside is that this method steals some CPU time, also, it cannot be 
used to patch program code in ROM.<BR>
As far as I rememeber, somewhat 10-25 codes can be used simultaneously.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="powerupsequence"></A><FONT SIZE=+2>&nbsp;Power Up Sequence</FONT></TD></TR></TABLE><BR>
When the GameBoy is powered up, a 256 byte program starting at memory location 0 is executed. This program is
located in a ROM inside the GameBoy. The first thing the program does is read the cartridge locations from $104
to $133 and place this graphic of a Nintendo logo on the screen at the top. This image is then scrolled until it
is in the middle of the screen. Two musical notes are then played on the internal speaker. Again, the cartridge
locations $104 to $133 are read but this time they are compared with a table in the internal rom. If any byte 
fails to compare, then the GameBoy stops comparing bytes and simply halts all operations. If all locations
compare the same, then the GameBoy starts adding all of the bytes in the cartridge from $134 to $14d. A value of
25 decimal is added to this total. If the least significant byte of the result is a not a zero, then the GameBoy
will stop doing anything. If it is a zero, then the internal ROM is disabled and cartridge program execution
begins at location $100 with the following register values:
<BR>
<BR>
<TABLE><TR><TD><PRE>   AF=$01B0
   BC=$0013
   DE=$00D8
   HL=$014D
   Stack Pointer=$FFFE
   [$FF05] = $00   ; TIMA
   [$FF06] = $00   ; TMA
   [$FF07] = $00   ; TAC
   [$FF10] = $80   ; NR10
   [$FF11] = $BF   ; NR11
   [$FF12] = $F3   ; NR12
   [$FF14] = $BF   ; NR14
   [$FF16] = $3F   ; NR21
   [$FF17] = $00   ; NR22
   [$FF19] = $BF   ; NR24
   [$FF1A] = $7F   ; NR30
   [$FF1B] = $FF   ; NR31
   [$FF1C] = $9F   ; NR32
   [$FF1E] = $BF   ; NR33
   [$FF20] = $FF   ; NR41
   [$FF21] = $00   ; NR42
   [$FF22] = $00   ; NR43
   [$FF23] = $BF   ; NR30
   [$FF24] = $77   ; NR50
   [$FF25] = $F3   ; NR51
   [$FF26] = $F1-GB, $F0-SGB ; NR52
   [$FF40] = $91   ; LCDC
   [$FF42] = $00   ; SCY
   [$FF43] = $00   ; SCX
   [$FF45] = $00   ; LYC
   [$FF47] = $FC   ; BGP
   [$FF48] = $FF   ; OBP0
   [$FF49] = $FF   ; OBP1
   [$FF4A] = $00   ; WY
   [$FF4B] = $00   ; WX
   [$FFFF] = $00   ; IE
</TD></TR></TABLE><BR>
It is not a good idea to assume the above values will always exist. A later version GameBoy could contain
different values than these at reset. Always set these registers on reset rather than assume they are 
as above.<BR>
<BR>
Please note that GameBoy internal RAM on power up contains random data.  All of the GameBoy emulators tend to set
all RAM to value $00 on entry.
<BR>
<BR>
Cart RAM the first time it is accessed on a real GameBoy contains random data. It will only contain known data if
the GameBoy code initializes it to some value.
<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="reducingpowerconsumption"></A><FONT SIZE=+2>&nbsp;Reducing Power Consumption</FONT></TD></TR></TABLE><BR>
The following can be used to recude the power consumption of the gameboy, and to extend the life of the
batteries.
<BR>
<BR>
<A HREF="#pwrusingthehaltinstruction">PWR Using the HALT Instruction</A><BR>
<A HREF="#pwrusingthestopinstruction">PWR Using the STOP Instruction</A><BR>
<A HREF="#pwrdisabelingthesoundcontroller">PWR Disabeling the Sound Controller</A><BR>
<A HREF="#pwrnotusingcgbdoublespeedmode">PWR Not using CGB Double Speed Mode</A><BR>
<A HREF="#pwrusingtheskills">PWR Using the Skills</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrusingthehaltinstruction"></A><FONT SIZE=+2>&nbsp;PWR Using the HALT Instruction</FONT></TD></TR></TABLE><BR>
It is recommended that the HALT instruction be used whenever possible to reduce power consumption & extend the
life of the batteries. This command stops the system clock reducing the power consumption of both the CPU and
ROM.
<BR>
<BR>
The CPU will remain suspended until an interrupt occurs at which point the interrupt is serviced and then the
instruction immediately following the HALT is executed.
<BR>
<BR>
Depending on how much CPU time is required by a game, the HALT instruction can extend battery life anywhere from
5 to 50% or possibly more.
<BR>
<BR>
When waiting for a vblank event, this would be a BAD example:<BR>
<TABLE><TR><TD><PRE>  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait
</TD></TR></TABLE><BR>
A better example would be a procedure as shown below. In this case the vblank interrupt must be enabled, and your
vblank interrupt procedure must set vblank_flag to a non-zero value.
<BR>
<TABLE><TR><TD><PRE>   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero
</TD></TR></TABLE>
The vblank_flag is used to determine whether the HALT period has been terminated by a vblank interrupt, or by
another interrupt. In case that your program has all other interrupts disabled, then it would be proof to replace
the above procedure by a single HALT instruction.
<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrusingthestopinstruction"></A><FONT SIZE=+2>&nbsp;PWR Using the STOP Instruction</FONT></TD></TR></TABLE><BR>
The STOP instruction is intended to switch the gameboy into VERY low power standby mode. For example, a program
may use this feature when it hasn't sensed keyboard input for a longer period (assuming that somebody forgot to
turn off the gameboy).
<BR>
<BR>
Before invoking STOP, it might be required to disable Sound and Video manually (as well as IR-link port in CGB).
Much like HALT, the STOP state is terminated by interrupt events - in this case this would be commonly a joypad
interrupt. The joypad register might be required to be prepared for STOP either.
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrdisabelingthesoundcontroller"></A><FONT SIZE=+2>&nbsp;PWR Disabeling the Sound Controller</FONT></TD></TR></TABLE><BR>
If your programs doesn't use sound at all (or during some periods) then write 00h to register FF26 to save 16% or
more on GB power consumption.
<BR>
Sound can be turned back on by writing 80h to the same register, all sound registers must be then re-initialized.
<BR>
When the gameboy becomes turned on, sound is enabled by default, and must be turned off manually when not used.
<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrnotusingcgbdoublespeedmode"></A><FONT SIZE=+2>&nbsp;PWR Not using CGB Double Speed Mode</FONT></TD></TR></TABLE><BR>
Because CGB Double Speed mode consumes more power, it'd be recommended to use normal speed when possible.
<BR>
There's limited ability to switch between both speeds, for example, a game might use normal speed in the title
screen, and double speed in the game, or vice versa.
<BR>
However, during speed switch the display collapses for a short moment, so that it'd be no good idea to alter
speeds within active game or title screen periods.
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrusingtheskills"></A><FONT SIZE=+2>&nbsp;PWR Using the Skills</FONT></TD></TR></TABLE><BR>
Most of the above power saving methods will produce best results when using efficient and tight assembler code
which requires as less CPU power as possible. Thus, experienced old-school programmers will (hopefully) produce
lower power consumption, as than HLL-programming teenagers, for example.
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="spriterambug"></A><FONT SIZE=+2>&nbsp;Sprite RAM Bug</FONT></TD></TR></TABLE><BR>
There is a flaw in the GameBoy hardware that causes trash to be written 
to OAM RAM if the following commands are used while their 16-bit content 
is in the range of $FE00 to $FEFF:<BR>
<TABLE><TR><TD><PRE>  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a
</TD></TR></TABLE>Only sprites 1 & 2 ($FE00 & $FE04) are not affected by these 
instructions.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="externalconnectors"></A><FONT SIZE=+2>&nbsp;External Connectors</FONT></TD></TR></TABLE><BR>
<B>Cartridge Slot<BR>
</B><TABLE><TR><TD><PRE>  Pin   Name    Expl.
  1     VDD     Power Supply +5V DC
  2     PHI     System Clock
  3     /WR     Write
  4     /RD     Read
  5     /CS     Chip Select
  6-21  A0-A15  Address Lines
  22-29 D0-D7   Data Lines
  30    /RES    Reset signal
  31    VIN     External Sound Input
  32    GND     Ground
</TD></TR></TABLE><BR>
<B>Link Port<BR>
</B>Pin numbers are arranged as 2,4,6 in upper row, 1,3,5 un lower row; 
outside view of gameboy socket; flat side of socket upside.<BR>
Colors as used in most or all standard link cables, because SIN and SOUT 
are crossed, colors Red and Orange are exchanged at one cable end.<BR>
<TABLE><TR><TD><PRE>  Pin Name Color  Expl.
  1   VCC  -      +5V DC
  2   SOUT red    Data Out
  3   SIN  orange Data In
  4   P14  -      Not used
  5   SCK  green  Shift Clock
  6   GND  blue   Ground
</TD></TR></TABLE>Note: The original gameboy used larger plugs (unlike pocket gameboys and 
newer), linking between older/newer gameboys is possible by using cables 
with one large and one small plug though.<BR>
<BR>
<B>Stereo Sound Connector (3.5mm, female)<BR>
</B><TABLE><TR><TD><PRE>  Pin     Expl.
  Tip     Sound Left
  Middle  Sound Right
  Base    Ground
</TD></TR></TABLE><BR>
<B>External Power Supply<BR>
</B>...<BR>
<BR>
<BR>
<BR>
  <TABLE WIDTH=100%>
   <TR bgcolor="#cccccc">
    <TD>
     <A NAME="end"></A><FONT SIZE=+2>&nbsp;END</FONT>
    </TD>
   </TR>
  </TABLE>
  </td></tr>
  <tr>
   <td>
    <p class = "summ">
     Page started December 2005, 
     <script>
      var date = new Date (document.lastModified);
      document.write ("last revised on " + date.toLocaleString() + "<br>");
      document.write ("This page located at " + document.URL + "<br>");
     </script>
    </p>
  
    <p class = "GB">Page equipped with FroogleBuster technology</p>
   </td>
  </tr>
  </table>
 </BODY>
</HTML>
